/** @typedef {import('../attribute').Attribute} Attribute */
const fs = require("fs");
const path = require("path");

const { AttributeType } = require('../attribute');
const { LanguageMeta } = require("./language");

class TypeScript extends LanguageMeta {
  getType(attribute, collections) {
    let type = ""
    switch (attribute.type) {
      case AttributeType.STRING:
      case AttributeType.EMAIL:
      case AttributeType.DATETIME:
      case AttributeType.IP:
      case AttributeType.URL:
        type = "string";
        if (attribute.format === AttributeType.ENUM) {
          type = LanguageMeta.toPascalCase(attribute.key);
        }
        break;
      case AttributeType.INTEGER:
        type = "number";
        break;
      case AttributeType.FLOAT:
        type = "number";
        break;
      case AttributeType.BOOLEAN:
        type = "boolean";
        break;
      case AttributeType.RELATIONSHIP:
        const relatedCollection = collections.find(c => c.$id === attribute.relatedCollection);
        if (!relatedCollection) {
          throw new Error(`Related collection with ID '${attribute.relatedCollection}' not found.`);
        }
        type = LanguageMeta.toPascalCase(relatedCollection.name);
        if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') {
          type = `${type}[]`;
        }
        break;
      default:
        throw new Error(`Unknown attribute type: ${attribute.type}`);
    }
    if (attribute.array) {
      type += "[]";
    }
    if (!attribute.required && attribute.default === null) {
      type += " | null";
    }
    return type;
  }

  isSingleFile() {
    return true;
  }

  _getAppwriteDependency() {
    if (fs.existsSync(path.resolve(process.cwd(), 'package.json'))) {
      const packageJsonRaw = fs.readFileSync(path.resolve(process.cwd(), 'package.json'));
      const packageJson = JSON.parse(packageJsonRaw.toString('utf-8'));
      return packageJson.dependencies['node-appwrite'] ? 'node-appwrite' : 'appwrite';
    }

    if (fs.existsSync(path.resolve(process.cwd(), 'deno.json'))) {
      return "https://deno.land/x/appwrite/mod.ts";
    }

    return "appwrite";
  }

  getTemplate() {
    return `import type { Models } from '${this._getAppwriteDependency()}';

// This file is auto-generated by the Appwrite CLI. 
// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(' ')}\`.

<% for (const collection of collections) { -%>
<% for (const attribute of collection.attributes) { -%>
<% if (attribute.format === 'enum') { -%>
export enum <%- toPascalCase(attribute.key) %> {
<% const entries = Object.entries(attribute.elements); -%>
<% for (let i = 0; i < entries.length; i++) { -%>
    <%- toUpperSnakeCase(entries[i][1]) %> = "<%- entries[i][1] %>"<% if (i !== entries.length - 1) { %>,<% } %>
<% } -%>
}

<% } -%>
<% } -%>
<% } -%>
<% for (const [index, collection] of Object.entries(collections)) { -%>
export type <%- toPascalCase(collection.name) %> = Models.Row & {
<% for (const attribute of collection.attributes) { -%>
<% const propertyName = strict ? toCamelCase(attribute.key) : attribute.key; -%>
<% const isValidIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propertyName); -%>
    <% if (isValidIdentifier) { %><%- propertyName %><% } else { %>"<%- propertyName %>"<% } %>: <%- getType(attribute, collections) %>;
<% } -%>
}<% if (index < collections.length - 1) { %>
<% } %>
<% } -%>`;
  }

  getFileName(_) {
    return "appwrite.d.ts";
  }
}

module.exports = { TypeScript };
