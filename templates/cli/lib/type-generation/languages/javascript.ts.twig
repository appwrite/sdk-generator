import fs = require('fs');
import path = require('path');
import { AttributeType } from '../attribute';
import { LanguageMeta, Attribute, Collection } from './language';

export class JavaScript extends LanguageMeta {
    getType(attribute: Attribute, collections?: Collection[]): string {
        let type = '';
        switch (attribute.type) {
            case AttributeType.STRING:
            case AttributeType.EMAIL:
            case AttributeType.DATETIME:
            case AttributeType.IP:
            case AttributeType.URL:
                type = 'string';
                if (attribute.format === AttributeType.ENUM) {
                    type = LanguageMeta.toPascalCase(attribute.key);
                }
                break;
            case AttributeType.INTEGER:
                type = 'number';
                break;
            case AttributeType.FLOAT:
                type = 'number';
                break;
            case AttributeType.BOOLEAN:
                type = 'boolean';
                break;
            case AttributeType.RELATIONSHIP:
                const relatedCollection = collections?.find((c) => c.$id === attribute.relatedCollection);
                if (!relatedCollection) {
                    throw new Error(`Related collection with ID '${attribute.relatedCollection}' not found.`);
                }
                type = LanguageMeta.toPascalCase(relatedCollection.name);
                if (
                    (attribute.relationType === 'oneToMany' && attribute.side === 'parent') ||
                    (attribute.relationType === 'manyToOne' && attribute.side === 'child') ||
                    attribute.relationType === 'manyToMany'
                ) {
                    type = `${type}[]`;
                }
                break;
            case AttributeType.POINT:
                type = 'number[]';
                break;
            case AttributeType.LINESTRING:
                type = 'number[][]';
                break;
            case AttributeType.POLYGON:
                type = 'number[][][]';
                break;
            default:
                throw new Error(`Unknown attribute type: ${attribute.type}`);
        }
        if (attribute.array) {
            type += '[]';
        }
        if (!attribute.required && attribute.default === null) {
            type += ' | null';
        }
        return type;
    }

    isSingleFile(): boolean {
        return true;
    }

    private _getAppwriteDependency(): string {
        if (fs.existsSync(path.resolve(process.cwd(), 'package.json'))) {
            const packageJsonRaw = fs.readFileSync(path.resolve(process.cwd(), 'package.json'));
            const packageJson = JSON.parse(packageJsonRaw.toString('utf-8'));
            return packageJson.dependencies && packageJson.dependencies['node-appwrite'] ? 'node-appwrite' : 'appwrite';
        }

        return 'appwrite';
    }

    getTemplate(): string {
        return `/**
 * @typedef {import('${this._getAppwriteDependency()}').Models.Row} Row
 */

// This file is auto-generated by the Appwrite CLI.
// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(' ')}\`.

<% for (const collection of collections) { -%>
<% for (const attribute of collection.attributes) { -%>
<% if (attribute.format === 'enum') { -%>
/**
 * @typedef {"<%- attribute.elements.join('"|"') %>"} <%- toPascalCase(attribute.key) %>
 */

<% } -%>
<% } -%>
<% } -%>
<% for (const [index, collection] of Object.entries(collections)) { %>/**
 * @typedef {Row & {
<% for (const attribute of collection.attributes) { -%>
 *   <%- strict ? toCamelCase(attribute.key) : attribute.key %>: <%- getType(attribute, collections) %>;
<% } -%>
 * }} <%- toPascalCase(collection.name) %>
 */
<% if (index < collections.length - 1) { %>
<% } -%>
<% } %>`;
    }

    getFileName(_: Collection | undefined): string {
        return 'appwrite-types.js';
    }
}
