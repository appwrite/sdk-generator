import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:web_socket_channel/status.dart' as status;
import 'exception.dart';
import 'realtime_subscription.dart';
import 'client.dart';
import 'realtime_message.dart';
import 'realtime_response.dart';
import 'realtime_response_connected.dart';

typedef WebSocketFactory = Future<WebSocketChannel> Function(Uri uri);
typedef GetFallbackCookie = String? Function();

mixin RealtimeMixin {
  late Client client;
  final Set<String> _channels = {};
  final Map<String, List<Set<String>>> _channelQueries = {}; // Map channel -> array of query sets (one per subscription)
  WebSocketChannel? _websok;
  String? _lastUrl;
  late WebSocketFactory getWebSocket;
  GetFallbackCookie? getFallbackCookie;
  int? get closeCode => _websok?.closeCode;
  final Map<int, RealtimeSubscription> _subscriptions = {};
  bool _reconnect = true;
  int _retries = 0;
  StreamSubscription? _websocketSubscription;
  bool _creatingSocket = false;
  Timer? _heartbeatTimer;

  Future<dynamic> _closeConnection() async {
    _stopHeartbeat();
    await _websocketSubscription?.cancel();
    await _websok?.sink.close(status.normalClosure, 'Ending session');
    _lastUrl = null;
    _retries = 0;
    _reconnect = false;
  }

  void _startHeartbeat() {
    _stopHeartbeat();
    _heartbeatTimer = Timer.periodic(Duration(seconds: 20), (_) {
      if (_websok != null) {
        _websok!.sink.add(jsonEncode({
          "type": "ping"
        }));
      }
    });
  }

  void _stopHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = null;
  }

  Future<void> _createSocket() async {
    if(_creatingSocket || _channels.isEmpty) return;
    _creatingSocket = true;
    final uri = _prepareUri();
    try {
      if (_websok == null || _websok?.closeCode != null) {
        _websok = await getWebSocket(uri);
        _lastUrl = uri.toString();
      } else {
        if (_lastUrl == uri.toString() && _websok?.closeCode == null) {
          _creatingSocket = false;
          return;
        }
        await _closeConnection();
        _lastUrl = uri.toString();
        _websok = await getWebSocket(uri);
      }
      _retries = 0;
      _websocketSubscription = _websok?.stream.listen((response) {
        final data = RealtimeResponse.fromJson(response);
        switch (data.type) {
          case 'error':
            handleError(data);
            break;
          case 'connected':
            // channels, user?
            final message = RealtimeResponseConnected.fromMap(data.data);
            if (message.user.isEmpty) {
              // send fallback cookie if exists
              final cookie = getFallbackCookie?.call();
              if (cookie != null) {
                _websok?.sink.add(jsonEncode({
                  "type": "authentication",
                  "data": {
                    "session": cookie,
                  },
                }));
              }
            }
            _startHeartbeat(); // Start heartbeat after successful connection
            break;
          case 'pong':
            debugPrint('Received heartbeat response from realtime server');
            break;
          case 'event':
            final messageData = data.data as Map<String, dynamic>;
            final message = RealtimeMessage.fromMap(messageData);
            // Queries structure: [[[q1, q2], [q3]], [[q4]]] - per channel, per subscription, queries
            final queriesData = (messageData['queries'] as List<dynamic>?)
                ?.map((x) => (x as List<dynamic>)
                    .map((y) => (y as List<dynamic>).cast<String>())
                    .toList())
                .toList() ?? <List<List<String>>>[];
            
            for (var subscription in _subscriptions.values) {
              // Check if subscription matches channels
              final hasSubscribedChannel = message.channels.any((channel) =>
                  subscription.channels.contains(channel));

              if (!hasSubscribedChannel) {
                continue;
              }

              // Check if subscription matches any query set from the response
              var matchesQueries = false;

              if (subscription.queries.isEmpty) {
                // Subscription has no queries - it listens to all events
                matchesQueries = true;
              } else if (queriesData.isNotEmpty) {
                // Flatten to get all query sets: [[q1, q2], [q3], [q4]]
                final allQuerySets = queriesData.expand((x) => x).toList();

                // Normalize subscription queries for comparison (parse and re-stringify)
                final normalizedSubQueries = <String>{};
                for (var q in subscription.queries) {
                  try {
                    final decoded = jsonDecode(q);
                    normalizedSubQueries.add(jsonEncode(decoded));
                  } catch (e) {
                    normalizedSubQueries.add(q);
                  }
                }

                // Check if any query set from response matches the subscription's query set
                for (var querySet in allQuerySets) {
                  // Check if this query set matches the subscription's queries
                  // A match means all queries in the response query set are in the subscription
                  final querySetMatches = querySet.isNotEmpty && querySet.every((query) {
                    // Normalize the query string from response
                    var normalizedQuery = query;
                    try {
                      final decoded = jsonDecode(query);
                      normalizedQuery = jsonEncode(decoded);
                    } catch (e) {
                      // If parsing fails, use original
                    }
                    return normalizedSubQueries.contains(normalizedQuery);
                  });

                  if (querySetMatches) {
                    matchesQueries = true;
                    break;
                  }
                }
              } else {
                // No queries in response, match all subscriptions
                matchesQueries = true;
              }

              if (!matchesQueries) {
                continue;
              }

              // Both channel and queries match, call the callback
              subscription.controller.add(message);
            }
            break;
        }
      }, onDone: () {
        _stopHeartbeat();
        _retry();
      }, onError: (err, stack) {
        _stopHeartbeat();
        for (var subscription in _subscriptions.values) {
          subscription.controller.addError(err, stack);
        }
        _retry();
      });
    } catch (e) {
      if (e is {{spec.title | caseUcfirst}}Exception) {
        rethrow;
      }
      debugPrint(e.toString());
      _retry();
    } finally {
      _creatingSocket = false;
    }
  }

  void _retry() async {
    if (!_reconnect || _websok?.closeCode == status.policyViolation) {
      _reconnect = true;
      return;
    }
    _retries++;
    debugPrint("Reconnecting in ${_getTimeout()} seconds.");
    Future.delayed(Duration(seconds: _getTimeout()), _createSocket);
  }

  int _getTimeout() {
    return _retries < 5
        ? 1
        : _retries < 15
            ? 5
            : _retries < 100
                ? 10
                : 60;
  }

  Uri _prepareUri() {
    if (client.endPointRealtime == null) {
      throw {{spec.title | caseUcfirst}}Exception(
          "Please set endPointRealtime to connect to realtime server");
    }
    var uri = Uri.parse(client.endPointRealtime!);
    
    // Build query string manually to support indexed array notation
    // Format: ch1[0][]=select("*")&ch1[1][]=q1&ch1[1][]=q2&ch2[0][]=select("*")
    // Each subscription gets its own index, queries within a subscription are grouped
    // Query.select(['*']) represents "no query filter" (listen to all events)
    var queryParams = "project=${Uri.encodeComponent(client.config['project']!)}";
    
    for (var channel in _channels) {
      final encodedChannel = Uri.encodeComponent(channel);
      queryParams += "&channels[]=$encodedChannel";
    }

    // Hardcode the select query string since Query is not accessible in this mixin
    // This is equivalent to Query.select(["*"]) which returns: {"method":"select","values":["*"]}
    final selectAllQuery = '{"method":"select","values":["*"]}';
    for (var channel in _channels) {
      final encodedChannel = Uri.encodeComponent(channel);
      final querySets = _channelQueries[channel];
      if (querySets != null && querySets.isNotEmpty) {
        for (var index = 0; index < querySets.length; index++) {
          final querySet = querySets[index];
          if (querySet.isEmpty) {
            // Subscription without queries - send select('*') to receive all events
            final encodedQuery = Uri.encodeComponent(selectAllQuery);
            queryParams += "&$encodedChannel[$index][]=$encodedQuery";
          } else {
            // Subscription with queries - group them under the same index
            for (var query in querySet) {
              final encodedQuery = Uri.encodeComponent(query);
              queryParams += "&$encodedChannel[$index][]=$encodedQuery";
            }
          }
        }
      } else {
        // No subscriptions, send select('*') at index 0
        final encodedQuery = Uri.encodeComponent(selectAllQuery);
        queryParams += "&$encodedChannel[0][]=$encodedQuery";
      }
    }

    return Uri.parse("${uri.scheme}://${uri.host}${uri.port != null && uri.port != 80 && uri.port != 443 ? ':${uri.port}' : ''}${uri.path}/realtime?$queryParams");
  }

  /// Convert channel value to string
  /// Handles String and Channel instances (which have toString())
  String _channelToString(Object channel) {
    return channel is String ? channel : channel.toString();
  }

  RealtimeSubscription subscribeTo(List<Object> channels, [List<String> queries = const []]) {
    StreamController<RealtimeMessage> controller = StreamController.broadcast();
    final channelStrings = channels.map((ch) => _channelToString(ch)).toList().cast<String>();
    final queryStrings = List<String>.from(queries);
    final queriesSet = queryStrings.toSet();

    for (var channel in channelStrings) {
      _channels.add(channel);
      // Associate this subscription's query set with the channel
      if (!_channelQueries.containsKey(channel)) {
        _channelQueries[channel] = [];
      }
      // Add this subscription's query set as a separate entry
      _channelQueries[channel]!.add(queriesSet);
    }

    Future.delayed(Duration.zero, () => _createSocket());
    int id = DateTime.now().microsecondsSinceEpoch;
    RealtimeSubscription subscription = RealtimeSubscription(
        controller: controller,
        channels: channelStrings,
        queries: queryStrings,
        close: () async {
          _subscriptions.remove(id);
          controller.close();
          _cleanup(channelStrings, queriesSet);

          if (_channels.isNotEmpty) {
            await Future.delayed(Duration.zero, () => _createSocket());
          } else {
            await _closeConnection();
          }
        });
    _subscriptions[id] = subscription;
    return subscription;
  }

  void _cleanup(List<String> channels, Set<String> queries) {
    for (var channel in channels) {
      final subsWithChannel = _subscriptions.values
          .where((subscription) => subscription.channels.contains(channel))
          .toList();
      
      if (subsWithChannel.isEmpty) {
        _channels.remove(channel);
        _channelQueries.remove(channel);
      } else {
        // Rebuild query sets for this channel from remaining subscriptions
        // Each subscription gets its own query set entry
        final querySets = <Set<String>>[];
        for (var sub in subsWithChannel) {
          querySets.add(sub.queries.toSet());
        }
        _channelQueries[channel] = querySets;
      }
    }
  }

  void handleError(RealtimeResponse response) {
    if (response.data['code'] == status.policyViolation) {
      throw {{spec.title | caseUcfirst}}Exception(response.data["message"], response.data["code"]);
    } else {
      _retry();
    }
  }
}