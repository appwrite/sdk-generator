import fs from "fs";
import path from "path";
import { AttributeType } from "../attribute.js";
import {
  LanguageMeta,
  Attribute,
  Collection,
  EnumDefinition,
  EnumMember,
} from "./language.js";

function generateEnumMembers(elements: string[]): EnumMember[] {
  const usedKeys = new Set<string>();

  return elements.map((element) => {
    let key = LanguageMeta.sanitizeEnumKey(element);
    if (usedKeys.has(key)) {
      let disambiguator = 1;
      while (usedKeys.has(`${key}_${disambiguator}`)) {
        disambiguator++;
      }
      key = `${key}_${disambiguator}`;
    }
    usedKeys.add(key);
    return { key, value: element };
  });
}

export class Dart extends LanguageMeta {
  getPackageName(): string {
    const pubspecPath = path.join(process.cwd(), "pubspec.yaml");
    if (fs.existsSync(pubspecPath)) {
      const pubspecContent = fs.readFileSync(pubspecPath, "utf8");
      const lines = pubspecContent.split("\n");

      const dependenciesIndex = lines.findIndex(
        (line) => line.trim() === "dependencies:",
      );

      if (dependenciesIndex !== -1) {
        const indent = lines[dependenciesIndex].search(/\S|$/);
        const dependencies: string[] = [];
        for (let i = dependenciesIndex + 1; i < lines.length; i++) {
          const line = lines[i];
          if (line.trim() === "") continue;

          const lineIndent = line.search(/\S|$/);
          if (lineIndent <= indent && line.trim() !== "") {
            break;
          }

          dependencies.push(line.trim());
        }

        if (dependencies.some((dep) => dep.startsWith("dart_appwrite:"))) {
          return "dart_appwrite";
        }
        if (dependencies.some((dep) => dep.startsWith("appwrite:"))) {
          return "appwrite";
        }
      }
    }

    return "appwrite";
  }

  getType(
    attribute: Attribute,
    collections?: Collection[],
    collectionName?: string,
  ): string {
    let type = "";
    switch (attribute.type) {
      case AttributeType.STRING:
      case AttributeType.TEXT:
      case AttributeType.VARCHAR:
      case AttributeType.MEDIUMTEXT:
      case AttributeType.LONGTEXT:
      case AttributeType.DATETIME:
        type = "String";
        if (attribute.format === AttributeType.ENUM) {
          type =
            LanguageMeta.toPascalCase(collectionName!) +
            LanguageMeta.toPascalCase(attribute.key);
        }
        break;
      case AttributeType.INTEGER:
        type = "int";
        break;
      case AttributeType.FLOAT:
        type = "double";
        break;
      case AttributeType.BOOLEAN:
        type = "bool";
        break;
      case AttributeType.RELATIONSHIP:
        const relatedCollection = LanguageMeta.getRelatedCollection(
          attribute,
          collections,
        );
        type = LanguageMeta.toPascalCase(relatedCollection.name);
        if (
          (attribute.relationType === "oneToMany" &&
            attribute.side === "parent") ||
          (attribute.relationType === "manyToOne" &&
            attribute.side === "child") ||
          attribute.relationType === "manyToMany"
        ) {
          type = `List<${type}>`;
        }
        break;
      case AttributeType.POINT:
        type = "List<double>";
        break;
      case AttributeType.LINESTRING:
        type = "List<List<double>>";
        break;
      case AttributeType.POLYGON:
        type = "List<List<List<double>>>";
        break;
      default:
        throw new Error(`Unknown attribute type: ${attribute.type}`);
    }
    if (attribute.array) {
      type = `List<${type}>`;
    }
    if (!attribute.required) {
      type += "?";
    }
    return type;
  }

  generateEnum(
    entityName: string,
    attributeKey: string,
    elements: string[],
  ): EnumDefinition {
    const name =
      LanguageMeta.toPascalCase(entityName) +
      LanguageMeta.toPascalCase(attributeKey);

    return {
      name,
      members: generateEnumMembers(elements),
    };
  }

  getTemplate(): string {
    return `// This file is auto-generated by the Appwrite CLI. 
// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(" ")}\`.
<% const __relatedImportsSeen = new Set();
   const sortedAttributes = collection.attributes.slice().sort((a, b) => {
     if (a.required === b.required) return 0;
     return a.required ? -1 : 1;
   }); -%>
<% const __attrs = sortedAttributes; -%>
<% for (const attribute of __attrs) { -%>
<%   if (attribute.type === '${AttributeType.RELATIONSHIP}') { -%>
<%     const related = getRelatedCollection(attribute, collections); -%>
<%     if (!__relatedImportsSeen.has(toSnakeCase(related.name))) { -%>
import '<%- toSnakeCase(related.name) %>.dart';
<%       __relatedImportsSeen.add(toSnakeCase(related.name)); -%>
<%     } -%>
<%   } -%>
<% } -%>

<% for (const attribute of __attrs) { -%>
<% if (attribute.format === '${AttributeType.ENUM}') { -%>
<% const enumDef = generateEnum(collection.name, attribute.key, Object.values(attribute.elements)); -%>
enum <%- enumDef.name %> {
<% for (let i = 0; i < enumDef.members.length; i++) { -%>
  <%- enumDef.members[i].key %>("<%- enumDef.members[i].value %>")<% if (i < enumDef.members.length - 1) { -%>,<% } else { -%>;<% } %>
<% } -%>

  const <%- enumDef.name %>(this.value);
  final String value;

  static <%- enumDef.name %>? fromValue(String? value) {
    if (value == null) return null;
    return <%- enumDef.name %>.values.firstWhere((element) => element.value == value);
  }
}

<% } -%>
<% } -%>
class <%= toPascalCase(collection.name) %> {
<% for (const [index, attribute] of Object.entries(__attrs)) { -%>
  <%- getType(attribute, collections, collection.name) %> <%= strict ? toCamelCase(attribute.key) : attribute.key %>;
<% } -%>

  <%= toPascalCase(collection.name) %>(<% if (__attrs.length > 0) { %>{
  <% for (const [index, attribute] of Object.entries(__attrs)) { -%>
  <% if (attribute.required) { %>required <% } %>this.<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (index < __attrs.length - 1) { -%>,<% } %>
  <% } -%>
}<% } %>);

  factory <%= toPascalCase(collection.name) %>.fromMap(Map<String, dynamic> map) {
    return <%= toPascalCase(collection.name) %>(<% if (__attrs.length > 0) { %>
<% for (const [index, attribute] of Object.entries(__attrs)) { -%>
      <%= strict ? toCamelCase(attribute.key) : attribute.key %>: <% if (['${AttributeType.STRING}', '${AttributeType.TEXT}', '${AttributeType.VARCHAR}', '${AttributeType.MEDIUMTEXT}', '${AttributeType.LONGTEXT}', '${AttributeType.EMAIL}', '${AttributeType.DATETIME}'].includes(attribute.type)) { -%>
<% if (attribute.format === '${AttributeType.ENUM}') { -%>
<% if (attribute.array) { -%>
(map['<%= attribute.key %>'] as List<dynamic>?)?.map((e) => <%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %>.values.firstWhere((element) => element.value == e)).toList()<% } else { -%>
<% if (!attribute.required) { -%>
<%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %>.fromValue(map['<%= attribute.key %>'])<% } else { -%>
<%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %>.values.firstWhere((e) => e.value == map['<%= attribute.key %>'])<% } -%>
<% } -%>
<% } else { -%>
<% if (attribute.array) { -%>
List<String>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% if (!attribute.required) { %>?<% } %>.toString()<% } -%>
<% } -%>
<% } else if (attribute.type === '${AttributeType.INTEGER}') { -%>
<% if (attribute.array) { -%>
List<int>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% } -%>
<% } else if (attribute.type === '${AttributeType.FLOAT}') { -%>
<% if (attribute.array) { -%>
List<double>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% } -%>
<% } else if (attribute.type === '${AttributeType.BOOLEAN}') { -%>
<% if (attribute.array) { -%>
List<bool>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% } -%>
<% } else if (attribute.type === '${AttributeType.RELATIONSHIP}') { -%>
<% const relatedClass = toPascalCase(getRelatedCollection(attribute, collections).name); -%>
<% if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') { -%>
(map['<%= attribute.key %>'] as List<dynamic>?)?.map((e) => <%- relatedClass %>.fromMap(e)).toList()<% } else { -%>
<% if (!attribute.required) { -%>
map['<%= attribute.key %>'] != null ? <%- relatedClass %>.fromMap(map['<%= attribute.key %>']) : null<% } else { -%>
<%- relatedClass %>.fromMap(map['<%= attribute.key %>'])<% } -%>
<% } -%>
<% } -%><% if (index < __attrs.length - 1) { -%>,<% } %>
<% } -%>
    <% } %>);
  }

  Map<String, dynamic> toMap() {
    return {
<% for (const [index, attribute] of Object.entries(__attrs)) { -%>
      '<%= attribute.key %>': <% if (attribute.type === '${AttributeType.RELATIONSHIP}') { -%>
<% if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.map((e) => e.toMap()).toList()<% } else { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.toMap()<% } -%>
<% } else if (attribute.format === '${AttributeType.ENUM}') { -%>
<% if (attribute.array) { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.map((e) => e.value).toList()<% } else { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.value<% } -%>
<% } else { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key -%>
<% } -%><% if (index < __attrs.length - 1) { -%>,<% } %>
<% } -%>
    };
  }
}
`;
  }

  getFileName(collection: Collection): string {
    return LanguageMeta.toSnakeCase(collection.name) + ".dart";
  }
}
