import {
  LanguageMeta,
  Attribute,
  Collection,
  EnumDefinition,
  EnumMember,
} from "./language.js";
import {
  getTypeScriptType,
  getAppwriteDependency,
  TypeAttribute,
  TypeEntity,
} from "../../shared/typescript-type-utils.js";

function generateEnumMembers(elements: string[]): EnumMember[] {
  const usedKeys = new Set<string>();

  return elements.map((element) => {
    let key = LanguageMeta.sanitizeEnumKey(element);
    if (usedKeys.has(key)) {
      let disambiguator = 1;
      while (usedKeys.has(`${key}_${disambiguator}`)) {
        disambiguator++;
      }
      key = `${key}_${disambiguator}`;
    }
    usedKeys.add(key);
    return { key, value: element };
  });
}

export class TypeScript extends LanguageMeta {
  getType(
    attribute: Attribute,
    collections?: Collection[],
    collectionName?: string,
  ): string {
    // Normalize relationship keys for shared TypeAttribute handling.
    const typeAttribute = {
      key: attribute.key,
      type: attribute.type,
      required: attribute.required,
      array: attribute.array,
      default: attribute.default,
      format: attribute.format,
      elements: attribute.elements,
      relatedCollection: LanguageMeta.getRelatedCollectionId(attribute),
      relationType: attribute.relationType,
      side: attribute.side,
    } as TypeAttribute;

    const entities: TypeEntity[] = (collections ?? []).map((c) => ({
      $id: c.$id,
      name: c.name,
    }));

    return getTypeScriptType(typeAttribute, entities, collectionName ?? "");
  }

  isSingleFile(): boolean {
    return true;
  }

  generateEnum(
    entityName: string,
    attributeKey: string,
    elements: string[],
  ): EnumDefinition {
    const name =
      LanguageMeta.toPascalCase(entityName) +
      LanguageMeta.toPascalCase(attributeKey);

    return {
      name,
      members: generateEnumMembers(elements),
    };
  }

  getTemplate(): string {
    const appwriteDep = getAppwriteDependency();

    return `import type { Models } from '${appwriteDep}';

// This file is auto-generated by the Appwrite CLI.
// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(" ")}\`.

<% for (const collection of collections) { -%>
<% for (const attribute of collection.attributes) { -%>
<% if (attribute.format === 'enum') { -%>
<% const enumDef = generateEnum(collection.name, attribute.key, Object.values(attribute.elements)); -%>
export enum <%- enumDef.name %> {
<% for (let i = 0; i < enumDef.members.length; i++) { -%>
    <%- enumDef.members[i].key %> = <%- JSON.stringify(enumDef.members[i].value) %><% if (i < enumDef.members.length - 1) { -%>,<% } %>
<% } -%>
}

<% } -%>
<% } -%>
<% } -%>
<% for (const [index, collection] of Object.entries(collections)) { -%>
export type <%- toPascalCase(collection.name) %> = Models.Row & {
<% for (const attribute of collection.attributes) { -%>
<% const propertyName = strict ? toCamelCase(attribute.key) : attribute.key; -%>
<% const isValidIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(propertyName); -%>
    <% if (isValidIdentifier) { %><%- propertyName %><% } else { %>"<%- propertyName %>"<% } %>: <%- getType(attribute, collections, collection.name) %>;
<% } -%>
}<% if (index < collections.length - 1) { %>
<% } %>
<% } -%>`;
  }

  getFileName(_: Collection | undefined): string {
    return "appwrite.d.ts";
  }
}
