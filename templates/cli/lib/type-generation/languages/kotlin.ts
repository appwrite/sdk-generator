import { AttributeType } from "../attribute.js";
import { LanguageMeta, Attribute, Collection } from "./language.js";

export class Kotlin extends LanguageMeta {
  getType(
    attribute: Attribute,
    collections?: Collection[],
    collectionName?: string,
  ): string {
    let type = "";
    switch (attribute.type) {
      case AttributeType.STRING:
      case AttributeType.TEXT:
      case AttributeType.VARCHAR:
      case AttributeType.MEDIUMTEXT:
      case AttributeType.LONGTEXT:
      case AttributeType.DATETIME:
        type = "String";
        if (attribute.format === AttributeType.ENUM) {
          type =
            LanguageMeta.toPascalCase(collectionName!) +
            LanguageMeta.toPascalCase(attribute.key);
        }
        break;
      case AttributeType.INTEGER:
        type = "Int";
        break;
      case AttributeType.FLOAT:
        type = "Float";
        break;
      case AttributeType.BOOLEAN:
        type = "Boolean";
        break;
      case AttributeType.RELATIONSHIP:
        const relatedCollection = LanguageMeta.getRelatedCollection(
          attribute,
          collections,
        );
        type = LanguageMeta.toPascalCase(relatedCollection.name);
        if (
          (attribute.relationType === "oneToMany" &&
            attribute.side === "parent") ||
          (attribute.relationType === "manyToOne" &&
            attribute.side === "child") ||
          attribute.relationType === "manyToMany"
        ) {
          type = `List<${type}>`;
        }
        break;
      case AttributeType.POINT:
        type = "List<Double>";
        break;
      case AttributeType.LINESTRING:
        type = "List<List<Double>>";
        break;
      case AttributeType.POLYGON:
        type = "List<List<List<Double>>>";
        break;
      default:
        throw new Error(`Unknown attribute type: ${attribute.type}`);
    }
    if (attribute.array) {
      type = "List<" + type + ">";
    }
    if (!attribute.required && attribute.default === null) {
      type += "?";
    }
    return type;
  }

  getTemplate(): string {
    return `package io.appwrite.models

<% for (const attribute of collection.attributes) { -%>
<% if (attribute.type === 'relationship') { -%>
<% const related = getRelatedCollection(attribute, collections); -%>
import <%- toPascalCase(related.name) %>

<% } -%>
<% } -%>
/**
 * This file is auto-generated by the Appwrite CLI. 
 * You can regenerate it by running \`appwrite ${process.argv.slice(2).join(" ")}\`.
 */

<% for (const attribute of collection.attributes) { -%>
<% if (attribute.format === 'enum') { -%>
enum class <%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %> {
<% for (const [index, element] of Object.entries(attribute.elements)) { -%>
    <%- strict ? toUpperSnakeCase(element) : element %><%- index < attribute.elements.length - 1 ? ',' : '' %>
<% } -%>
}

<% } -%>
<% } -%>
data class <%- toPascalCase(collection.name) %>(
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
    val <%- strict ? toCamelCase(attribute.key) : attribute.key %>: <%- getType(attribute, collections, collection.name) %><% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
)
`;
  }

  getFileName(collection: Collection): string {
    return LanguageMeta.toPascalCase(collection.name) + ".kt";
  }
}
