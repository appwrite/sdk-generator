import Foundation

// Marker structs for type safety (structs work with == constraints in extensions)
public struct Root {}
public struct Database {}
public struct Collection {}
public struct Document {}
public struct TablesDB {}
public struct Table {}
public struct Row {}
public struct Bucket {}
public struct File {}
public struct Func {}
public struct Execution {}
public struct Team {}
public struct Membership {}
public struct Resolved {}

// Helper for normalizing IDs
private func normalize(_ id: String) -> String {
    let trimmed = id.trimmingCharacters(in: .whitespacesAndNewlines)
    return trimmed.isEmpty ? "*" : trimmed
}

/// Channel class with generic type parameter for type-safe method chaining
public class RealtimeChannel<T> {
    private let segments: [String]
    
    internal init(_ segments: [String]) {
        self.segments = segments
    }
    
    /// Internal helper to transition to next state with segment and ID
    internal func next<N>(_ segment: String, _ id: String = "*") -> RealtimeChannel<N> {
        return RealtimeChannel<N>(segments + [segment, normalize(id)])
    }
    
    /// Internal helper for terminal actions (no ID segment)
    internal func resolve(_ action: String) -> RealtimeChannel<Resolved> {
        return RealtimeChannel<Resolved>(segments + [action])
    }
    
    /// Convert channel to string representation
    public func toString() -> String {
        return segments.joined(separator: ".")
    }
}

/// Non-generic Channel enum for static factory methods
public enum Channel {
    
    // MARK: - Root Factories
    
    public static func database(_ id: String = "*") -> RealtimeChannel<Database> {
        return RealtimeChannel<Database>(["databases", normalize(id)])
    }
    
    public static func tablesdb(_ id: String = "*") -> RealtimeChannel<TablesDB> {
        return RealtimeChannel<TablesDB>(["tablesdb", normalize(id)])
    }
    
    public static func bucket(_ id: String = "*") -> RealtimeChannel<Bucket> {
        return RealtimeChannel<Bucket>(["buckets", normalize(id)])
    }
    
    public static func function(_ id: String = "*") -> RealtimeChannel<Func> {
        return RealtimeChannel<Func>(["functions", normalize(id)])
    }
    
    public static func team(_ id: String = "*") -> RealtimeChannel<Team> {
        return RealtimeChannel<Team>(["teams", normalize(id)])
    }
    
    public static func membership(_ id: String = "*") -> RealtimeChannel<Membership> {
        return RealtimeChannel<Membership>(["memberships", normalize(id)])
    }
    
    public static func account(_ userId: String = "") -> String {
        let id = normalize(userId)
        return id == "*" ? "account" : "account.\(id)"
    }
    
    // Global events
    public static var documents: String { "documents" }
    public static var rows: String { "rows" }
    public static var files: String { "files" }
    public static var executions: String { "executions" }
}

// MARK: - DATABASE ROUTE
// Protocol extensions restricted by receiver type

/// Only available on RealtimeChannel<Database>
extension RealtimeChannel where T == Database {
    public func collection(_ id: String = "*") -> RealtimeChannel<Collection> {
        return self.next("collections", id)
    }
}

/// Only available on RealtimeChannel<Collection>
extension RealtimeChannel where T == Collection {
    public func document(_ id: String = "*") -> RealtimeChannel<Document> {
        return self.next("documents", id)
    }
}

// MARK: - TABLESDB ROUTE

/// Only available on RealtimeChannel<TablesDB>
extension RealtimeChannel where T == TablesDB {
    public func table(_ id: String = "*") -> RealtimeChannel<Table> {
        return self.next("tables", id)
    }
}

/// Only available on RealtimeChannel<Table>
extension RealtimeChannel where T == Table {
    public func row(_ id: String = "*") -> RealtimeChannel<Row> {
        return self.next("rows", id)
    }
}

// MARK: - BUCKET ROUTE

/// Only available on RealtimeChannel<Bucket>
extension RealtimeChannel where T == Bucket {
    public func file(_ id: String = "*") -> RealtimeChannel<File> {
        return self.next("files", id)
    }
}

// MARK: - FUNCTION ROUTE

/// Only available on RealtimeChannel<Func>
extension RealtimeChannel where T == Func {
    public func execution(_ id: String = "*") -> RealtimeChannel<Execution> {
        return self.next("executions", id)
    }
}

// MARK: - TERMINAL ACTIONS
// Restricted to actionable types (Document, Row, File, Execution, Team, Membership)

/// Only available on RealtimeChannel<Document>
extension RealtimeChannel where T == Document {
    public func create() -> RealtimeChannel<Resolved> {
        return self.resolve("create")
    }
    
    public func update() -> RealtimeChannel<Resolved> {
        return self.resolve("update")
    }
    
    public func delete() -> RealtimeChannel<Resolved> {
        return self.resolve("delete")
    }
}

/// Only available on RealtimeChannel<Row>
extension RealtimeChannel where T == Row {
    public func create() -> RealtimeChannel<Resolved> {
        return self.resolve("create")
    }
    
    public func update() -> RealtimeChannel<Resolved> {
        return self.resolve("update")
    }
    
    public func delete() -> RealtimeChannel<Resolved> {
        return self.resolve("delete")
    }
}

/// Only available on RealtimeChannel<File>
extension RealtimeChannel where T == File {
    public func create() -> RealtimeChannel<Resolved> {
        return self.resolve("create")
    }
    
    public func update() -> RealtimeChannel<Resolved> {
        return self.resolve("update")
    }
    
    public func delete() -> RealtimeChannel<Resolved> {
        return self.resolve("delete")
    }
}

/// Only available on RealtimeChannel<Execution>
extension RealtimeChannel where T == Execution {
    public func create() -> RealtimeChannel<Resolved> {
        return self.resolve("create")
    }
    
    public func update() -> RealtimeChannel<Resolved> {
        return self.resolve("update")
    }
    
    public func delete() -> RealtimeChannel<Resolved> {
        return self.resolve("delete")
    }
}

/// Only available on RealtimeChannel<Team>
extension RealtimeChannel where T == Team {
    public func create() -> RealtimeChannel<Resolved> {
        return self.resolve("create")
    }
    
    public func update() -> RealtimeChannel<Resolved> {
        return self.resolve("update")
    }
    
    public func delete() -> RealtimeChannel<Resolved> {
        return self.resolve("delete")
    }
}

/// Only available on RealtimeChannel<Membership>
extension RealtimeChannel where T == Membership {
    public func create() -> RealtimeChannel<Resolved> {
        return self.resolve("create")
    }
    
    public func update() -> RealtimeChannel<Resolved> {
        return self.resolve("update")
    }
    
    public func delete() -> RealtimeChannel<Resolved> {
        return self.resolve("delete")
    }
}

// MARK: - Protocol for backward compatibility

/// Protocol for channel values that can be converted to strings
public protocol ChannelValue {
    func toString() -> String
}

// Make String conform to ChannelValue
extension String: ChannelValue {
    public func toString() -> String {
        return self
    }
}

// Make RealtimeChannel conform to ChannelValue
extension RealtimeChannel: ChannelValue {}
