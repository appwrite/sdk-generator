type QueryValue = string | number | boolean;
export type QueryTypesSingle = string | number | boolean;
export type QueryTypesList = string[] | number[] | boolean[] | Query[] | any[];
export type QueryTypes = QueryTypesSingle | QueryTypesList;

export type Query = {
    method: string;
    attribute?: string | string[];
    values?: QueryValue[];
};

export function equal<K extends string>(attribute: K, value: QueryValue): Query & { attribute: K } {
    return { method: 'equal', attribute, values: [value] };
}

export function notEqual<K extends string>(attribute: K, value: QueryValue): Query & { attribute: K } {
    return { method: 'notEqual', attribute, values: [value] };
}

export function lessThan<K extends string>(attribute: K, value: QueryValue): Query & { attribute: K } {
    return { method: 'lessThan', attribute, values: [value] };
}

export function lessThanEqual<K extends string>(attribute: K, value: QueryValue): Query & { attribute: K } {
    return { method: 'lessThanEqual', attribute, values: [value] };
}

export function greaterThan<K extends string>(attribute: K, value: QueryValue): Query & { attribute: K } {
    return { method: 'greaterThan', attribute, values: [value] };
}

export function greaterThanEqual<K extends string>(attribute: K, value: QueryValue): Query & { attribute: K } {
    return { method: 'greaterThanEqual', attribute, values: [value] };
}

export function isNull<K extends string>(attribute: K): Query & { attribute: K } {
    return { method: 'isNull', attribute };
}

export function isNotNull<K extends string>(attribute: K): Query & { attribute: K } {
    return { method: 'isNotNull', attribute };
}

export function between<K extends string>(attribute: K, start: QueryValue, end: QueryValue): Query & { attribute: K } {
    return { method: 'between', attribute, values: [start, end] };
}

export function startsWith<K extends string>(attribute: K, value: string): Query & { attribute: K } {
    return { method: 'startsWith', attribute, values: [value] };
}

export function endsWith<K extends string>(attribute: K, value: string): Query & { attribute: K } {
    return { method: 'endsWith', attribute, values: [value] };
}

export function select(attributes: string[]): Query {
    return { method: 'select', values: attributes };
}

export function search<K extends string>(attribute: K, value: string): Query & { attribute: K } {
    return { method: 'search', attribute, values: [value] };
}

export function orderDesc<K extends string>(attribute: K): Query & { attribute: K } {
    return { method: 'orderDesc', attribute };
}

export function orderAsc<K extends string>(attribute: K): Query & { attribute: K } {
    return { method: 'orderAsc', attribute };
}

export function orderRandom(): Query {
    return { method: 'orderRandom' };
}

export function cursorAfter(documentId: string): Query {
    return { method: 'cursorAfter', values: [documentId] };
}

export function cursorBefore(documentId: string): Query {
    return { method: 'cursorBefore', values: [documentId] };
}

export function limit(limit: number): Query {
    return { method: 'limit', values: [limit] };
}

export function offset(offset: number): Query {
    return { method: 'offset', values: [offset] };
}

export function contains<K extends string>(attribute: K, value: string | string[]): Query & { attribute: K } {
    return { method: 'contains', attribute, values: Array.isArray(value) ? value : [value] };
}

export function notContains<K extends string>(attribute: K, value: string | string[]): Query & { attribute: K } {
    return { method: 'notContains', attribute, values: Array.isArray(value) ? value : [value] };
}

export function notSearch<K extends string>(attribute: K, value: string): Query & { attribute: K } {
    return { method: 'notSearch', attribute, values: [value] };
}

export function notBetween<K extends string>(attribute: K, start: QueryValue, end: QueryValue): Query & { attribute: K } {
    return { method: 'notBetween', attribute, values: [start, end] };
}

export function notStartsWith<K extends string>(attribute: K, value: string): Query & { attribute: K } {
    return { method: 'notStartsWith', attribute, values: [value] };
}

export function notEndsWith<K extends string>(attribute: K, value: string): Query & { attribute: K } {
    return { method: 'notEndsWith', attribute, values: [value] };
}

export function createdBefore(value: string): Query {
    return lessThan('$createdAt', value);
}

export function createdAfter(value: string): Query {
    return greaterThan('$createdAt', value);
}

export function createdBetween(start: string, end: string): Query {
    return between('$createdAt', start, end);
}

export function updatedBefore(value: string): Query {
    return lessThan('$updatedAt', value);
}

export function updatedAfter(value: string): Query {
    return greaterThan('$updatedAt', value);
}

export function updatedBetween(start: string, end: string): Query {
    return between('$updatedAt', start, end);
}

export function or(...queries: Query[]): Query {
    return { method: 'or', values: queries as unknown as QueryValue[] };
}

export function and(...queries: Query[]): Query {
    return { method: 'and', values: queries as unknown as QueryValue[] };
}

export function distanceEqual(attribute: string, values: any[], distance: number, meters: boolean = true): Query {
    return { method: 'distanceEqual', attribute, values: [[values, distance, meters]] as unknown as QueryValue[] };
}

export function distanceNotEqual(attribute: string, values: any[], distance: number, meters: boolean = true): Query {
    return { method: 'distanceNotEqual', attribute, values: [[values, distance, meters]] as unknown as QueryValue[] };
}

export function distanceGreaterThan(attribute: string, values: any[], distance: number, meters: boolean = true): Query {
    return { method: 'distanceGreaterThan', attribute, values: [[values, distance, meters]] as unknown as QueryValue[] };
}

export function distanceLessThan(attribute: string, values: any[], distance: number, meters: boolean = true): Query {
    return { method: 'distanceLessThan', attribute, values: [[values, distance, meters]] as unknown as QueryValue[] };
}

export function intersects(attribute: string, values: any[]): Query {
    return { method: 'intersects', attribute, values: [values] as unknown as QueryValue[] };
}

export function notIntersects(attribute: string, values: any[]): Query {
    return { method: 'notIntersects', attribute, values: [values] as unknown as QueryValue[] };
}

export function crosses(attribute: string, values: any[]): Query {
    return { method: 'crosses', attribute, values: [values] as unknown as QueryValue[] };
}

export function notCrosses(attribute: string, values: any[]): Query {
    return { method: 'notCrosses', attribute, values: [values] as unknown as QueryValue[] };
}

export function overlaps(attribute: string, values: any[]): Query {
    return { method: 'overlaps', attribute, values: [values] as unknown as QueryValue[] };
}

export function notOverlaps(attribute: string, values: any[]): Query {
    return { method: 'notOverlaps', attribute, values: [values] as unknown as QueryValue[] };
}

export function touches(attribute: string, values: any[]): Query {
    return { method: 'touches', attribute, values: [values] as unknown as QueryValue[] };
}

export function notTouches(attribute: string, values: any[]): Query {
    return { method: 'notTouches', attribute, values: [values] as unknown as QueryValue[] };
}

function queryToString(query: Query): string {
    return JSON.stringify(query);
}

export function serializeQueries(queries: Query[] | undefined): string[] | undefined {
    if (!queries) return undefined;
    return queries.map(queryToString);
}

export const ops = {
    equal,
    notEqual,
    lessThan,
    lessThanEqual,
    greaterThan,
    greaterThanEqual,
    isNull,
    isNotNull,
    between,
    startsWith,
    endsWith,
    select,
    search,
    orderDesc,
    orderAsc,
    orderRandom,
    cursorAfter,
    cursorBefore,
    limit,
    offset,
    contains,
    notContains,
    notSearch,
    notBetween,
    notStartsWith,
    notEndsWith,
    createdBefore,
    createdAfter,
    createdBetween,
    updatedBefore,
    updatedAfter,
    updatedBetween,
    or,
    and,
    distanceEqual,
    distanceNotEqual,
    distanceGreaterThan,
    distanceLessThan,
    intersects,
    notIntersects,
    crosses,
    notCrosses,
    overlaps,
    notOverlaps,
    touches,
    notTouches,
};

type ExtractModel<T> = T extends { [key: string]: any } ? T : never;

type QueryForModel<T> = {
    equal<K extends keyof T & string>(attribute: K, value: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    notEqual<K extends keyof T & string>(attribute: K, value: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    lessThan<K extends keyof T & string>(attribute: K, value: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    lessThanEqual<K extends keyof T & string>(attribute: K, value: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    greaterThan<K extends keyof T & string>(attribute: K, value: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    greaterThanEqual<K extends keyof T & string>(attribute: K, value: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    isNull<K extends keyof T & string>(attribute: K): Query & { attribute: K };
    isNotNull<K extends keyof T & string>(attribute: K): Query & { attribute: K };
    between<K extends keyof T & string>(attribute: K, start: T[K] extends QueryValue ? T[K] : QueryValue, end: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    startsWith<K extends keyof T & string>(attribute: K, value: string): Query & { attribute: K };
    endsWith<K extends keyof T & string>(attribute: K, value: string): Query & { attribute: K };
    select(attributes: (keyof T & string)[]): Query;
    search<K extends keyof T & string>(attribute: K, value: string): Query & { attribute: K };
    orderDesc<K extends keyof T & string>(attribute: K): Query & { attribute: K };
    orderAsc<K extends keyof T & string>(attribute: K): Query & { attribute: K };
    orderRandom(): Query;
    cursorAfter(documentId: string): Query;
    cursorBefore(documentId: string): Query;
    limit(limit: number): Query;
    offset(offset: number): Query;
    contains<K extends keyof T & string>(attribute: K, value: string | string[]): Query & { attribute: K };
    notContains<K extends keyof T & string>(attribute: K, value: string | string[]): Query & { attribute: K };
    notSearch<K extends keyof T & string>(attribute: K, value: string): Query & { attribute: K };
    notBetween<K extends keyof T & string>(attribute: K, start: T[K] extends QueryValue ? T[K] : QueryValue, end: T[K] extends QueryValue ? T[K] : QueryValue): Query & { attribute: K };
    notStartsWith<K extends keyof T & string>(attribute: K, value: string): Query & { attribute: K };
    notEndsWith<K extends keyof T & string>(attribute: K, value: string): Query & { attribute: K };
    createdBefore(value: string): Query;
    createdAfter(value: string): Query;
    createdBetween(start: string, end: string): Query;
    updatedBefore(value: string): Query;
    updatedAfter(value: string): Query;
    updatedBetween(start: string, end: string): Query;
    or(...queries: Query[]): Query;
    and(...queries: Query[]): Query;
    distanceEqual(attribute: string, values: any[], distance: number, meters?: boolean): Query;
    distanceNotEqual(attribute: string, values: any[], distance: number, meters?: boolean): Query;
    distanceGreaterThan(attribute: string, values: any[], distance: number, meters?: boolean): Query;
    distanceLessThan(attribute: string, values: any[], distance: number, meters?: boolean): Query;
    intersects(attribute: string, values: any[]): Query;
    notIntersects(attribute: string, values: any[]): Query;
    crosses(attribute: string, values: any[]): Query;
    notCrosses(attribute: string, values: any[]): Query;
    overlaps(attribute: string, values: any[]): Query;
    notOverlaps(attribute: string, values: any[]): Query;
    touches(attribute: string, values: any[]): Query;
    notTouches(attribute: string, values: any[]): Query;
};

export type ModelOps<T> = QueryForModel<ExtractModel<T>>;
