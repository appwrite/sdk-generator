import Foundation
import AsyncHTTPClient
import NIO
import NIOHTTP1

open class Realtime : Service {

    private let TYPE_ERROR = "error"
    private let TYPE_EVENT = "event"
    private let TYPE_PONG = "pong"
    private let DEBOUNCE_NANOS = 1_000_000
    private let HEARTBEAT_INTERVAL: UInt64 = 20_000_000_000 // 20 seconds in nanoseconds

    private var socketClient: WebSocketClient? = nil
    private var activeChannels = Set<String>()
    private var channelQueries = [String: [Set<String>]]() // Map channel -> array of query sets (one per subscription)
    private var activeSubscriptions = [Int: RealtimeCallback]()
    private var activeSubscriptionQueries = [Int: Set<String>]()
    private var heartbeatTask: Task<Void, Swift.Error>? = nil

    let connectSync = DispatchQueue(label: "ConnectSync")

    private var subCallDepth = 0
    private var reconnectAttempts = 0
    private var subscriptionsCounter = 0
    private var reconnect = true
    
    private var onErrorCallbacks: [((Swift.Error?, HTTPResponseStatus?) -> Void)] = []
    private var onCloseCallbacks: [(() -> Void)] = []
    private var onOpenCallbacks: [(() -> Void)] = []

    public func onError(_ callback: @escaping (Swift.Error?, HTTPResponseStatus?) -> Void) {
        self.onErrorCallbacks.append(callback)
    }
    
    public func onClose(_ callback: @escaping () -> Void) {
        self.onCloseCallbacks.append(callback)
    }
    
    public func onOpen(_ callback: @escaping () -> Void) {
        self.onOpenCallbacks.append(callback)
    }

    private func startHeartbeat() {
        stopHeartbeat()
        heartbeatTask = Task {
            do {
                while !Task.isCancelled {
                    if let client = socketClient, client.isConnected {
                        client.send(text: #"{"type": "ping"}"#)
                    }
                    try await Task.sleep(nanoseconds: HEARTBEAT_INTERVAL)
                }
            } catch {
                if !Task.isCancelled {
                    print("Heartbeat task failed: \(error.localizedDescription)")
                }
            }
        }
    }

    private func stopHeartbeat() {
        heartbeatTask?.cancel()
        heartbeatTask = nil
    }

    private func createSocket() async throws {
        guard activeChannels.count > 0 else {
            reconnect = false
            try await closeSocket()
            return
        }

        var queryParams = "project=\(client.config["project"]!)"

        for channel in activeChannels {
            let encodedChannel = channel.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? channel
            queryParams += "&channels[]=\(encodedChannel)"
        }

        // Add queries associated with each channel using indexed array notation
        // Format: ch1[0][]=select("*")&ch1[1][]=q1&ch1[1][]=q2&ch2[0][]=select("*")
        // Each subscription gets its own index, queries within a subscription are grouped
        // Query.select(['*']) represents "no query filter" (listen to all events)
        let selectAllQuery = Query.select(["*"])
        for channel in activeChannels {
            let encodedChannel = channel.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? channel
            if let querySets = channelQueries[channel], querySets.count > 0 {
                for (index, querySet) in querySets.enumerated() {
                    if querySet.isEmpty {
                        // Subscription without queries - send select('*') to receive all events
                        let encodedQuery = selectAllQuery.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? selectAllQuery
                        queryParams += "&\(encodedChannel)[\(index)][]=\(encodedQuery)"
                    } else {
                        // Subscription with queries - group them under the same index
                        for query in querySet {
                            let encodedQuery = query.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? query
                            queryParams += "&\(encodedChannel)[\(index)][]=\(encodedQuery)"
                        }
                    }
                }
            } else {
                // No subscriptions, send select('*') at index 0
                let encodedQuery = selectAllQuery.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? selectAllQuery
                queryParams += "&\(encodedChannel)[0][]=\(encodedQuery)"
            }
        }

        let url = "\(client.endPointRealtime!)/realtime?\(queryParams)"

        if (socketClient != nil) {
            reconnect = false
            try await closeSocket()
        }

        socketClient = WebSocketClient(
            url,
            tlsEnabled: !client.selfSigned,
            delegate: self
        )

        try await socketClient?.connect()
    }

    private func closeSocket() async throws {
        stopHeartbeat()
        
        guard let client = socketClient,
              let group = client.threadGroup else {
            return
        }

        if (client.isConnected) {
            let promise = group.any().makePromise(of: Void.self)
            client.close(promise: promise)
            try await promise.futureResult.get()
        }

        try await group.shutdownGracefully()
    }

    private func getTimeout() -> Int {
        switch reconnectAttempts {
        case 0..<5: return 1000
        case 5..<15: return 5000
        case 15..<100: return 10000
        default: return 60000
        }
    }

    /**
     * Convert channel value to string
     * All Channel instances and String conform to ChannelValue
     */
    private func channelToString(_ channel: ChannelValue) -> String {
        return channel.toString()
    }

    public func subscribe(
        channel: ChannelValue,
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set([channelToString(channel)]),
            payloadType: String.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe(
        channels: [ChannelValue],
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set(channels.map { channelToString($0) }),
            payloadType: String.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe<T : Codable>(
        channel: ChannelValue,
        payloadType: T.Type,
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set([channelToString(channel)]),
            payloadType: T.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe<T : Codable>(
        channels: [ChannelValue],
        payloadType: T.Type,
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set(channels.map { channelToString($0) }),
            payloadType: T.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe<T : Codable>(
        channels: Set<String>,
        payloadType: T.Type,
        queries: [String] = [],
        callback: @escaping (RealtimeResponseEvent) -> Void
    ) async throws -> RealtimeSubscription {
        subscriptionsCounter += 1

        let count = subscriptionsCounter

        let queriesSet = Set(queries)

        for channel in channels {
            activeChannels.insert(channel)
            // Associate this subscription's query set with the channel
            if channelQueries[channel] == nil {
                channelQueries[channel] = []
            }
            // Add this subscription's query set as a separate entry
            channelQueries[channel]!.append(queriesSet)
        }

        activeSubscriptions[count] = RealtimeCallback(
            for: Set(channels),
            with: callback
        )
        activeSubscriptionQueries[count] = queriesSet

        connectSync.sync {
            subCallDepth+=1
        }

        try await Task.sleep(nanoseconds: UInt64(DEBOUNCE_NANOS))

        if self.subCallDepth == 1 {
            try await self.createSocket()
        }

        connectSync.sync {
            self.subCallDepth -= 1
        }

        return RealtimeSubscription {
            self.activeSubscriptions[count] = nil
            self.activeSubscriptionQueries[count] = nil
            self.cleanUp(channels: channels, queries: Set(queries))
            try await self.createSocket()
        }
    }

    func cleanUp(channels: Set<String>, queries: Set<String>) {
        activeChannels = activeChannels.filter { channel in
            if !channels.contains(channel) {
                return true
            }

            let subsWithChannel = activeSubscriptions.values.filter { sub in
                return sub.channels.contains(channel)
            }

            return !subsWithChannel.isEmpty
        }

        // Clean up channel-query associations
        for channel in channels {
            let subsWithChannel = activeSubscriptions.values.filter { sub in
                return sub.channels.contains(channel)
            }

            if subsWithChannel.isEmpty {
                // No more subscriptions for this channel, remove it
                channelQueries.removeValue(forKey: channel)
            } else {
                // Rebuild query sets for this channel from remaining subscriptions
                // Each subscription gets its own query set entry
                var querySets: [Set<String>] = []
                // Rebuild from all active subscriptions that include this channel
                for (subId, sub) in activeSubscriptions {
                    if sub.channels.contains(channel), let subQueries = activeSubscriptionQueries[subId] {
                        querySets.append(subQueries)
                    }
                }
                channelQueries[channel] = querySets
            }
        }
    }
}

extension Realtime: WebSocketClientDelegate {

    public func onOpen(channel: NIO.Channel) {
        self.reconnectAttempts = 0
        onOpenCallbacks.forEach { $0() }
        startHeartbeat()
    }

    public func onMessage(text: String) {
        let data = Data(text.utf8)
        if let json = try! JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
            if let type = json["type"] as? String {
                switch type {
                case TYPE_ERROR: try! handleResponseError(from: json)
                case TYPE_EVENT: handleResponseEvent(from: json)
                case TYPE_PONG: break  // Handle pong response if needed
                default: break
                }
            }
        }
    }

    public func onClose(channel: NIO.Channel, data: Data) async throws {
        stopHeartbeat()

        onCloseCallbacks.forEach { $0() }
        
        if (!reconnect) {
            reconnect = true
            return
        }

        let timeout = getTimeout()

        print("Realtime disconnected. Re-connecting in \(timeout / 1000) seconds.")

        try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000))

        self.reconnectAttempts += 1

        try await self.createSocket()
    }

    public func onError(error: Swift.Error?, status: HTTPResponseStatus?) {
        stopHeartbeat()
        print(error?.localizedDescription ?? "Unknown error")

        onErrorCallbacks.forEach { $0(error, status) }
    }

    func handleResponseError(from json: [String: Any]) throws {
        throw {{ spec.title | caseUcfirst }}Error(message: json["message"] as? String ?? "Unknown error")
    }

    func handleResponseEvent(from json: [String: Any]) {
        guard let data = json["data"] as? [String: Any],
              let channels = data["channels"] as? [String],
              let events = data["events"] as? [String],
              let payload = data["payload"] as? [String: Any] else {
            return
        }
        guard channels.contains(where: { channel in
            activeChannels.contains(channel)
        }) else {
            return
        }

        // Queries structure: [[[q1, q2], [q3]], [[q4]]] - per channel, per subscription, queries
        let queriesData = data["queries"] as? [[[String]]] ?? []

        for (subId, subscription) in activeSubscriptions {
            // Check if subscription matches channels
            let hasSubscribedChannel = channels.contains(where: { channel in
                subscription.channels.contains(channel)
            })

            if !hasSubscribedChannel {
                continue
            }

            // Check if subscription matches any query set from the response
            var matchesQueries = false

            guard let subQueries = activeSubscriptionQueries[subId] else {
                continue
            }

            if subQueries.isEmpty {
                // Subscription has no queries - it listens to all events
                matchesQueries = true
            } else if !queriesData.isEmpty {
                // Flatten to get all query sets: [[q1, q2], [q3], [q4]]
                let allQuerySets = queriesData.flatMap { $0 }

                // Normalize subscription queries for comparison (parse and re-stringify)
                var normalizedSubQueries = Set<String>()
                for q in subQueries {
                    if let data = q.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data),
                       let normalized = try? JSONSerialization.data(withJSONObject: json),
                       let normalizedString = String(data: normalized, encoding: .utf8) {
                        normalizedSubQueries.insert(normalizedString)
                    } else {
                        normalizedSubQueries.insert(q)
                    }
                }

                // Check if any query set from response matches the subscription's query set
                for querySet in allQuerySets {
                    // Check if this query set matches the subscription's queries
                    // A match means all queries in the response query set are in the subscription
                    let querySetMatches = !querySet.isEmpty && querySet.allSatisfy { query in
                        // Normalize the query string from response
                        var normalizedQuery = query
                        if let data = query.data(using: .utf8),
                           let json = try? JSONSerialization.jsonObject(with: data),
                           let normalized = try? JSONSerialization.data(withJSONObject: json),
                           let normalizedString = String(data: normalized, encoding: .utf8) {
                            normalizedQuery = normalizedString
                        }
                        return normalizedSubQueries.contains(normalizedQuery)
                    }

                    if querySetMatches {
                        matchesQueries = true
                        break
                    }
                }
            } else {
                // No queries in response, match all subscriptions
                matchesQueries = true
            }

            if !matchesQueries {
                continue
            }

            // Both channel and queries match, call the callback
            let response = RealtimeResponseEvent(
                events: events,
                channels: channels,
                timestamp: data["timestamp"] as! String,
                payload: payload
            )
            subscription.callback(response)
        }
    }
}
