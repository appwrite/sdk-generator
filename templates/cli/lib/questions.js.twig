const chalk = require("chalk");
const Client = require("./client");
const { localConfig, globalConfig } = require('./config');
const { projectsList } = require('./commands/projects');
const { teamsList } = require('./commands/teams');
const { functionsListRuntimes, functionsList } = require('./commands/functions');
const { accountListMfaFactors } = require("./commands/account");
const { sdkForConsole } = require("./sdks");
const { validateRequired } = require("./validations");
const { paginate } = require('./paginate');
const { databasesList } = require('./commands/databases');
const { checkDeployConditions } = require('./utils');
const JSONbig = require("json-bigint")({ storeAsString: false });

const whenOverride = (answers) => answers.override === undefined ? true : answers.override;

const getIgnores = (runtime) => {
    const languge = runtime.split('-')[0];

    switch (languge) {
        case 'cpp':
            return ['build', 'CMakeFiles', 'CMakeCaches.txt'];
        case 'dart':
            return ['.packages', '.dart_tool'];
        case 'deno':
            return [];
        case 'dotnet':
            return ['bin', 'obj', '.nuget'];
        case 'java':
        case 'kotlin':
            return ['build'];
        case 'node':
        case 'bun':
            return ['node_modules', '.npm'];
        case 'php':
            return ['vendor'];
        case 'python':
            return ['__pypackages__'];
        case 'ruby':
            return ['vendor'];
        case 'rust':
            return ['target', 'debug', '*.rs.bk', '*.pdb'];
        case 'swift':
            return ['.build', '.swiftpm'];
    }

    return undefined;
};

const getEntrypoint = (runtime) => {
    const languge = runtime.split('-')[0];

    switch (languge) {
        case 'dart':
            return 'lib/main.dart';
        case 'deno':
            return 'src/main.ts';
        case 'node':
            return 'src/main.js';
        case 'bun':
            return 'src/main.ts';
        case 'php':
            return 'src/index.php';
        case 'python':
            return 'src/main.py';
        case 'ruby':
            return 'lib/main.rb';
        case 'rust':
            return 'main.rs';
        case 'swift':
            return 'Sources/index.swift';
        case 'cpp':
            return 'src/main.cc';
        case 'dotnet':
            return 'src/Index.cs';
        case 'java':
            return 'src/Main.java';
        case 'kotlin':
            return 'src/Main.kt';
    }

    return undefined;
};

const getInstallCommand = (runtime) => {
    const languge = runtime.split('-')[0];

    switch (languge) {
        case 'dart':
            return 'dart pub get';
        case 'deno':
            return "deno install";
        case 'node':
            return 'npm install';
        case 'bun':
            return 'bun install';
        case 'php':
            return 'composer install';
        case 'python':
            return 'pip install -r requirements.txt';
        case 'ruby':
            return 'bundle install';
        case 'rust':
            return 'cargo install';
        case 'dotnet':
            return 'dotnet restore';
        case 'swift':
        case 'java':
        case 'kotlin':
        case 'cpp':
            return '';
    }

    return undefined;
};

const questionsInitProject = [
    {
        type: "confirm",
        name: "override",
        message:
            `An {{ spec.title|caseUcfirst }} project ( ${localConfig.getProject()['projectName']} ) is already associated with the current directory. Would you like to override`,
        when() {
            return Object.keys(localConfig.getProject()).length !== 0;
        }
    },
    {
        type: "list",
        name: "organization",
        message: "Choose the project organization",
        choices: async () => {
            let client = await sdkForConsole(true);
            const { teams } = await paginate(teamsList, { parseOutput: false, sdk: client }, 100, 'teams');

            let choices = teams.map((team, idx) => {
                return {
                    name: `${team.name} (${team['$id']})`,
                    value: {
                        name: team.name,
                        id: team['$id']
                    }
                }
            })

            if (choices.length == 0) {
                throw new Error("No organizations found. Please create a new organization.")
            }

            return choices;
        },
        when: whenOverride
    },
    {
        type: "list",
        name: "start",
        when(answers) {
            if (answers.override == undefined) {
                return true
            }
            return answers.override;
        },
        message: "How would you like to start?",
        choices: [
            {
                name: "Create a new {{ spec.title|caseUcfirst }} project",
                value: "new"
            },
            {
                name: "Link this directory to an existing {{ spec.title|caseUcfirst }} project",
                value: "existing"
            }
        ]
    },
    {
        type: "input",
        name: "project",
        message: "What would you like to name your project?",
        default: "My Awesome Project",
        when: (answer) => answer.start === 'new'
    },
    {
        type: "input",
        name: "id",
        message: "What ID would you like to have for your project?",
        default: "unique()",
        when: (answer) => answer.start === 'new'
    },
    {
        type: "list",
        name: "project",
        message: "Choose your {{ spec.title|caseUcfirst }} project.",
        choices: async (answers) => {
            let response = await projectsList({
                parseOutput: false,
                queries: [JSON.stringify({ method: 'equal', attribute: 'teamId', values: [answers.organization.id] })],
            })
            let projects = response["projects"]
            let choices = projects.map((project, idx) => {
                return {
                    name: `${project.name} (${project['$id']})`,
                    value: {
                        name: project.name,
                        id: project['$id']
                    }
                }
            })

            if (choices.length == 0) {
                throw new Error("No projects found. Please create a new project.")
            }

            return choices;
        },
        when: (answer) => answer.start === 'existing'
    }
];
const questionsPullResources = [
    {
        type: "checkbox",
        name: "resources",
        message: "Which resources would you like to pull?",
        choices: [
            { name: 'Project', value: 'project' },
            { name: 'Functions', value: 'functions' },
            { name: 'Collections', value: 'collections' },
            { name: 'Buckets', value: 'buckets' },
            { name: 'Teams', value: 'teams' },
            { name: 'Topics', value: 'messages' }
        ]
    }
]

const questionsPullFunctions = [
    {
        type: "checkbox",
        name: "functions",
        message: "Which functions would you like to pull?",
        validate: (value) => validateRequired('function', value),
        choices: async () => {
            const { functions } = await paginate(functionsList, { parseOutput: false }, 100, 'functions');

            if (functions.length === 0) {
                throw "We couldn't find any functions in your {{ spec.title|caseUcfirst }} project";
            }

            return functions.map(func => {
                return {
                    name: `${func.name} (${func.$id})`,
                    value: func
                }
            });
        }
    }
];

const questionsCreateFunction = [
    {
        type: "input",
        name: "name",
        message: "What would you like to name your function?",
        default: "My Awesome Function"
    },
    {
        type: "input",
        name: "id",
        message: "What ID would you like to have for your function?",
        default: "unique()"
    },
    {
        type: "list",
        name: "runtime",
        message: "What runtime would you like to use?",
        choices: async () => {
            let response = await functionsListRuntimes({
                parseOutput: false
            })
            let runtimes = response["runtimes"]
            let choices = runtimes.map((runtime, idx) => {
                return {
                    name: `${runtime.name} (${runtime['$id']})`,
                    value: {
                        id: runtime['$id'],
                        name: runtime['$id'].split('-')[0],
                        entrypoint: getEntrypoint(runtime['$id']),
                        ignore: getIgnores(runtime['$id']),
                        commands: getInstallCommand(runtime['$id'])
                    },
                }
            })
            return choices;
        }
    }
];

const questionsCreateFunctionSelectTemplate = (templates) => {
    return [
        {
            type: "list",
            name: "template",
            message: "What template would you like to use?",
            choices: templates.map((template) => {
                const name = `${template[0].toUpperCase()}${template.split('').slice(1).join('')}`.replace(/[-_]/g, ' ');

                return { value: template, name }
            })
        }
    ];
};



const questionsCreateBucket = [
    {
        type: "input",
        name: "bucket",
        message: "What would you like to name your bucket?",
        default: "My Awesome Bucket"
    },
    {
        type: "input",
        name: "id",
        message: "What ID would you like to have for your bucket?",
        default: "unique()"
    },
    {
        type: "list",
        name: "fileSecurity",
        message: "Enable File-Security configuring permissions for individual file",
        choices: ["No", "Yes"]
    }
];

const questionsCreateCollection = [
    {
        type: "list",
        name: "database",
        message: "Choose the collection database",
        choices: async () => {
            const { databases } = await paginate(databasesList, { parseOutput: false }, 100, 'databases');

            let choices = databases.map((database, idx) => {
                return {
                    name: `${database.name} (${database.$id})`,
                    value: database.$id
                }
            })

            if (choices.length === 0) {
                throw new Error("No databases found. Please create one in project console.")
            }

            return choices;
        }
    },
    {
        type: "input",
        name: "collection",
        message: "What would you like to name your collection?",
        default: "My Awesome Collection"
    },
    {
        type: "input",
        name: "id",
        message: "What ID would you like to have for your collection?",
        default: "unique()"
    },
    {
        type: "list",
        name: "documentSecurity",
        message: "Enable Document-Security for configuring permissions for individual documents",
        choices: ["No", "Yes"]
    }
];

const questionsCreateMessagingTopic = [
    {
        type: "input",
        name: "topic",
        message: "What would you like to name your messaging topic?",
        default: "My Awesome Topic"
    },
    {
        type: "input",
        name: "id",
        message: "What ID would you like to have for your messaging topic?",
        default: "unique()"
    }
];

const questionsPullCollection = [
    {
        type: "checkbox",
        name: "databases",
        message: "From which database would you like to pull collections?",
        validate: (value) => validateRequired('collection', value),
        choices: async () => {
            let response = await databasesList({
                parseOutput: false
            })
            let databases = response["databases"]

            if (databases.length <= 0) {
                throw new Error("No databases found. Please create one in project console.")
            }
            let choices = databases.map((database, idx) => {
                return {
                    name: `${database.name} (${database.$id})`,
                    value: database.$id
                }
            })
            return choices;
        }
    }
];

const questionsLogin = [
    {
        type: "list",
        name: "method",
        message: "You're already logged in, what you like to do?",
        choices: [
            { name: 'Login to a different account', value: 'login' },
            { name: 'Change to a different existed account', value: 'select' }
        ],
        when: () => globalConfig.getCurrentLogin() !== ''
    },
    {
        type: "input",
        name: "email",
        message: "Enter your email",
        validate(value) {
            if (!value) {
                return "Please enter your email";
            }
            return true;
        },
        when: (answers) => answers.method !== 'select'
    },
    {
        type: "password",
        name: "password",
        message: "Enter your password",
        mask: "*",
        validate(value) {
            if (!value) {
                return "Please enter your password";
            }
            return true;
        },
        when: (answers) => answers.method !== 'select'
    },
    {
        type: "list",
        name: "accountId",
        message: "Select an account to use",
        choices() {
            const logins = globalConfig.getLogins();
            const current = globalConfig.getCurrentLogin();

            const data = [];

            const longestEmail = logins.reduce((prev, current) => (prev && (prev.email ?? '').length > (current.email ?? '').length) ? prev : current).email.length;

            logins.forEach((login) => {
                if (login.email) {
                    data.push({
                        current: current === login.id,
                        value: login.id,
                        name: `${login.email.padEnd(longestEmail)} ${current === login.id ? chalk.green.bold('current') : ' '.repeat(6)} ${login.endpoint}`,
                    });
                }
            })

            return data.sort((a, b) => Number(b.current) - Number(a.current))
        },
        when: (answers) => answers.method === 'select'
    },
];
const questionGetEndpoint = [
    {
        type: "input",
        name: "endpoint",
        message: "Enter the endpoint of your {{ spec.title|caseUcfirst }} server",
        default: "http://localhost/v1",
        async validate(value) {
            if (!value) {
                return "Please enter a valid endpoint.";
            }
            let client = new Client().setEndpoint(value);
            try {
                let response = await client.call('get', '/health/version');
                if (response.version) {
                    return true;
                } else {
                    throw new Error();
                }
            } catch (error) {
                return "Invalid endpoint or your Appwrite server is not running as expected.";
            }
        }
    }
];

const questionLoginWithEndpoint = [
    questionsLogin[0],
    { ...questionGetEndpoint[0], when: (answers) => answers.method !== 'select' },
    questionsLogin[1],
    questionsLogin[2],
    questionsLogin[3]
]

const questionsLogout = [
    {
        type: "checkbox",
        name: "accounts",
        message: "Select accounts to logout from",
        validate: (value) => validateRequired('account', value),
        choices() {
            const logins = globalConfig.getLogins();
            const current = globalConfig.getCurrentLogin();

            const data = [];

            const longestEmail = logins.reduce((prev, current) => (prev && (prev.email ?? '').length > (current.email ?? '').length) ? prev : current).email.length;

            logins.forEach((login) => {
                if (login.email) {
                    data.push({
                        current: current === login.id,
                        value: login.id,
                        name: `${login.email.padEnd(longestEmail)} ${current === login.id ? chalk.green.bold('current') : ' '.repeat(6)} ${login.endpoint}`,
                    });
                }
            })

            return data.sort((a, b) => Number(b.current) - Number(a.current))
        }
    }
];

const questionsPushResources = [
    {
        type: "checkbox",
        name: "resources",
        message: "Which resources would you like to push?",
        choices: [
            { name: 'Project', value: 'project' },
            { name: 'Functions', value: 'functions' },
            { name: 'Collections', value: 'collections' },
            { name: 'Buckets', value: 'buckets' },
            { name: 'Teams', value: 'teams' },
            { name: 'Topics', value: 'messages' }
        ]
    }
]

const questionsPushFunctions = [
    {
        type: "checkbox",
        name: "functions",
        message: "Which functions would you like to push?",
        validate: (value) => validateRequired('function', value),
        choices: () => {
            let functions = localConfig.getFunctions();
            checkDeployConditions(localConfig)
            if (functions.length === 0) {
                throw new Error("No functions found in the current directory.");
            }
            let choices = functions.map((func, idx) => {
                return {
                    name: `${func.name} (${func.$id})`,
                    value: func.$id
                }
            })
            return choices;
        }
    },
    {
        type: "input",
        name: "override",
        message: 'Are you sure you want to override this function\'s variables? This can lead to loss of secrets! Type "YES" to confirm.'
    },
]

const questionsPushCollections = [
    {
        type: "checkbox",
        name: "collections",
        message: "Which collections would you like to push?",
        validate: (value) => validateRequired('collection', value),
        choices: () => {
            let collections = localConfig.getCollections();
            checkDeployConditions(localConfig)

            if (collections.length === 0) {
                throw new Error("No collections found in the current directory. Run `{{ language.params.executableName }} pull collection` to fetch all your collections.");
            }
            return collections.map(collection => {
                return {
                    name: `${collection.name} (${collection['databaseId']} - ${collection['$id']})`,
                    value: `${collection['databaseId']}|${collection['$id']}`
                }
            });
        }
    },
    {
        type: "input",
        name: "changes",
        message: `Are you sure you want to override this collection? This can lead to loss of data! Type "YES" to confirm.`
    }
]

const questionsPushBuckets = [
    {
        type: "checkbox",
        name: "buckets",
        message: "Which buckets would you like to push?",
        validate: (value) => validateRequired('bucket', value),
        choices: () => {
            let buckets = localConfig.getBuckets();
            checkDeployConditions(localConfig)
            if (buckets.length === 0) {
                throw new Error("No buckets found in the current directory. Run `appwrite pull bucket` to fetch all your buckets.");
            }
            return buckets.map(bucket => {
                return {
                    name: `${bucket.name} (${bucket['$id']})`,
                    value: bucket.$id
                }
            });
        }
    },
    {
        type: "input",
        name: "override",
        message: 'Are you sure you want to override this bucket? This can lead to loss of data! Type "YES" to confirm.'
    },
]

const questionsPushMessagingTopics = [
    {
        type: "checkbox",
        name: "topics",
        message: "Which messaging topic would you like to push?",
        choices: () => {
            let topics = localConfig.getMessagingTopics();
            if (topics.length === 0) {
                throw new Error("No topics found in the current directory. Run `appwrite pull messaging` to fetch all your messaging topics.");
            }
            return topics.map(topic => {
                return {
                    name: `${topic.name} (${topic['$id']})`,
                    value: topic.$id
                }
            });
        }
    },
    {
        type: "input",
        name: "override",
        message: 'Would you like to override existing topics? This can lead to loss of data! Type "YES" to confirm.'
    }
]

const questionsGetEntrypoint = [
    {
        type: "input",
        name: "entrypoint",
        message: "Enter the entrypoint",
        default: null,
        validate(value) {
            if (!value) {
                return "Please enter your entrypoint";
            }
            return true;
        }
    },
]

const questionsPushTeams = [
    {
        type: "checkbox",
        name: "teams",
        message: "Which teams would you like to push?",
        validate: (value) => validateRequired('team', value),
        choices: () => {
            let teams = localConfig.getTeams();
            checkDeployConditions(localConfig);
            if (teams.length === 0) {
                throw new Error("No teams found in the current directory. Run `appwrite pull team` to fetch all your teams.");
            }
            return teams.map(team => {
                return {
                    name: `${team.name} (${team['$id']})`,
                    value: team.$id
                }
            });
        }
    },
    {
        type: "input",
        name: "override",
        message: 'Are you sure you want to override this team? This can lead to loss of data! Type "YES" to confirm.'
    },
];

const questionsListFactors = [
    {
        type: "list",
        name: "factor",
        message: "Your account is protected by multiple factors. Which factor would you like to use to authenticate?",
        choices: async () => {
            let client = await sdkForConsole(false);
            const factors = await accountListMfaFactors({
                sdk: client,
                parseOutput: false
            });

            const choices = [
                {
                    name: `TOTP (Time-based One-time Password)`,
                    value: 'totp'
                },
                {
                    name: `E-mail`,
                    value: 'email'
                },
                {
                    name: `Phone (SMS)`,
                    value: 'phone'
                },
                {
                    name: `Recovery code`,
                    value: 'recoveryCode'
                }
            ].filter((ch) => factors[ch.value] === true);

            return choices;
        }
    }
];

const questionsMfaChallenge = [
    {
        type: "input",
        name: "otp",
        message: "Enter OTP",
        validate(value) {
            if (!value) {
                return "Please enter OTP";
            }
            return true;
        },
    }
];



module.exports = {
    questionsInitProject,
    questionsCreateFunction,
    questionsCreateFunctionSelectTemplate,
    questionsCreateBucket,
    questionsCreateCollection,
    questionsCreateMessagingTopic,
    questionsPullFunctions,
    questionsLogin,
    questionsPullResources,
    questionsLogout,
    questionsPullCollection,
    questionsPushResources,
    questionsPushFunctions,
    questionsPushCollections,
    questionsPushBuckets,
    questionsPushMessagingTopics,
    questionsPushTeams,
    questionsGetEntrypoint,
    questionsListFactors,
    questionsMfaChallenge,
    questionGetEndpoint,
    questionLoginWithEndpoint
};
