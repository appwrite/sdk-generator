/** @typedef {import('../attribute').Attribute} Attribute */
const { AttributeType } = require('../attribute');
const { LanguageMeta } = require("./language");

class CSharp extends LanguageMeta {
  getType(attribute, collections, collectionName) {
    let type = "";
    switch (attribute.type) {
      case AttributeType.STRING:
      case AttributeType.EMAIL:
      case AttributeType.DATETIME:
        type = "string";
        if (attribute.format === AttributeType.ENUM) {
          type = LanguageMeta.toPascalCase(collectionName) + LanguageMeta.toPascalCase(attribute.key);
        }
        break;
      case AttributeType.INTEGER:
        type = "long";
        break;
      case AttributeType.FLOAT:
        type = "double";
        break;
      case AttributeType.BOOLEAN:
        type = "bool";
        break;
      case AttributeType.RELATIONSHIP:
        const relatedCollection = collections.find(c => c.$id === attribute.relatedCollection);
        if (!relatedCollection) {
          throw new Error(`Related collection with ID '${attribute.relatedCollection}' not found.`);
        }
        type = LanguageMeta.toPascalCase(relatedCollection.name);
        if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') {
          type = `List<${type}>`;
        }
        break;
      default:
        throw new Error(`Unknown attribute type: ${attribute.type}`);
    }
    if (attribute.array) {
      type = `List<${type}>`;
    }
    if (!attribute.required) {
      type += "?";
    }
    return type;
  }

  getTemplate() {
    return `/// This file is auto-generated by the Appwrite CLI. 
/// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(' ')}\`.

#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;

namespace Appwrite.Models
{
<% for (const attribute of collection.attributes) { -%>
<% if (attribute.format === 'enum') { -%>

public enum <%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %> {
<% for (const [index, element] of Object.entries(attribute.elements) ) { -%>
    [JsonPropertyName("<%- element %>")]
    <%- toPascalCase(element) %><% if (index < attribute.elements.length - 1) { %>,<% } %>
<% } -%>
}
<% } -%>
<% } %>
public class <%= toPascalCase(collection.name) %>
{
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
    [JsonPropertyName("<%- attribute.key %>")]
    public <%- getType(attribute, collections, collection.name) %> <%= toPascalCase(attribute.key) %> { get; private set; }

<% } -%>

    public <%= toPascalCase(collection.name) %>(
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
        <%- getType(attribute, collections, collection.name) %> <%= toCamelCase(attribute.key) %><% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
    )
    {
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
        <%= toPascalCase(attribute.key) %> = <%= toCamelCase(attribute.key) %>;
<% } -%>
    }

    public static <%= toPascalCase(collection.name) %> From(Dictionary<string, object> map) => new <%= toPascalCase(collection.name) %>(
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
        <%- toCamelCase(attribute.key) %>: <%
            // ENUM
            if (attribute.format === 'enum') {
                if (attribute.array) {
                    -%>((IEnumerable<object>)map["<%- attribute.key %>"]).Select(e => Enum.Parse<Models.<%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %>>(e.ToString()!, true)).ToList()<%
                } else {
                    -%>Enum.Parse<Models.<%- toPascalCase(collection.name) %><%- toPascalCase(attribute.key) %>>(map["<%- attribute.key %>"].ToString()!, true)<%
                }
            // RELATIONSHIP
            } else if (attribute.type === 'relationship') {
                const relatedClass = toPascalCase(collections.find(c => c.$id === attribute.relatedCollection).name);
                if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany' || attribute.array) {
                    -%>((IEnumerable<object>)map["<%- attribute.key %>"]).Select(it => Models.<%- relatedClass %>.From((Dictionary<string, object>)it)).ToList()<%
                } else {
                    -%>Models.<%- relatedClass %>.From((Dictionary<string, object>)map["<%- attribute.key %>"])<%
                }
            // ARRAY TYPES
            } else if (attribute.array) {
                if (attribute.type === 'string' || attribute.type === 'datetime' || attribute.type === 'email') {
                    -%>((IEnumerable<object>)map["<%- attribute.key %>"]).Select(x => x?.ToString())<%- attribute.required ? '.Where(x => x != null)' : '' %>.ToList()!<%
                } else if (attribute.type === 'integer') {
                    -%>((IEnumerable<object>)map["<%- attribute.key %>"]).Select(x => <%- !attribute.required ? 'x == null ? (long?)null : ' : '' %>Convert.ToInt64(x)).ToList()<%
                } else if (attribute.type === 'double') {
                    -%>((IEnumerable<object>)map["<%- attribute.key %>"]).Select(x => <%- !attribute.required ? 'x == null ? (double?)null : ' : '' %>Convert.ToDouble(x)).ToList()<%
                } else if (attribute.type === 'boolean') {
                    -%>((IEnumerable<object>)map["<%- attribute.key %>"]).Select(x => <%- !attribute.required ? 'x == null ? (bool?)null : ' : '' %>(bool)x).ToList()<%
                }
            // SINGLE VALUE TYPES
            } else if (attribute.type === 'integer') {
                -%><%- !attribute.required ? 'map["' + attribute.key + '"] == null ? null : ' : '' %>Convert.ToInt64(map["<%- attribute.key %>"])<%
            } else if (attribute.type === 'double') {
                -%><%- !attribute.required ? 'map["' + attribute.key + '"] == null ? null : ' : '' %>Convert.ToDouble(map["<%- attribute.key %>"])<%
            } else if (attribute.type === 'boolean') {
                -%>(<%- getType(attribute, collections) %>)map["<%- attribute.key %>"]<%
            } else if (attribute.type === 'string' || attribute.type === 'datetime' || attribute.type === 'email') {
                -%>map["<%- attribute.key %>"]<%- !attribute.required ? '?' : '' %>.ToString()<%- attribute.required ? '!' : ''%><%
            } else {
                -%>default<%
            }
            -%><% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
    );

    public Dictionary<string, object?> ToMap() => new Dictionary<string, object?>()
    {
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
        { "<%- attribute.key %>", <%
        // ENUM
        if (attribute.format === 'enum') {
            if (attribute.array) {
                -%><%= toPascalCase(attribute.key) %>?.Select(e => e.ToString()).ToList()<%
            } else {
                -%><%= toPascalCase(attribute.key) %>?.ToString()<%
            }
        // RELATIONSHIP
        } else if (attribute.type === 'relationship') {
            if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany' || attribute.array) {
                -%><%= toPascalCase(attribute.key) %>?.Select(e => e.ToMap()).ToList()<%
            } else {
                -%><%= toPascalCase(attribute.key) %>?.ToMap()<%
            }
        // OTHER
        } else {
            -%><%= toPascalCase(attribute.key) %><%
        }
        -%> }<% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
    };
}
}
`;
  }

  getFileName(collection) {
    return LanguageMeta.toPascalCase(collection.name) + ".cs";
  }
}

module.exports = { CSharp };
