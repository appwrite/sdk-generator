const inquirer = require("inquirer");
const JSONbig = require("json-bigint")({ storeAsString: false });
const { Command } = require("commander");
const { localConfig } = require("../config");
const { paginate } = require('../paginate');
const { questionsPushBuckets, questionsPushTeams, questionsPushFunctions, questionsGetEntrypoint, questionsPushCollections, questionsConfirmPushCollections, questionsPushMessagingTopics } = require("../questions");
const { actionRunner, success, log, error, commandDescriptions } = require("../parser");
const { functionsGet, functionsCreate, functionsUpdate, functionsCreateDeployment, functionsUpdateDeployment, functionsListVariables, functionsDeleteVariable, functionsCreateVariable } = require('./functions');
const {
    databasesGet,
    databasesCreate,
    databasesUpdate,
    databasesCreateBooleanAttribute,
    databasesGetCollection,
    databasesCreateCollection,
    databasesCreateStringAttribute,
    databasesCreateIntegerAttribute,
    databasesCreateFloatAttribute,
    databasesCreateEmailAttribute,
    databasesCreateDatetimeAttribute,
    databasesCreateIndex,
    databasesCreateUrlAttribute,
    databasesCreateIpAttribute,
    databasesCreateEnumAttribute,
    databasesCreateRelationshipAttribute,
    databasesDeleteAttribute,
    databasesListAttributes,
    databasesListIndexes,
    databasesDeleteIndex,
    databasesUpdateCollection
} = require("./databases");
const {
    storageGetBucket, storageUpdateBucket, storageCreateBucket
} = require("./storage");
const {
    messagingGetTopic, messagingUpdateTopic, messagingCreateTopic
} = require("./messaging");
const {
    teamsGet,
    teamsUpdate,
    teamsCreate
} = require("./teams");

const STEP_SIZE = 100;      // Resources
const POOL_DEBOUNCE = 2000; // Milliseconds

let poolMaxDebounces = 30;

const awaitPools = {
    wipeAttributes: async (databaseId, collectionId, iteration = 1) => {
        if (iteration > poolMaxDebounces) {
            return false;
        }

        const { total } = await databasesListAttributes({
            databaseId,
            collectionId,
            queries: [JSON.stringify({ method: 'limit', values: [1] })],
            parseOutput: false
        });

        if (total === 0) {
            return true;
        }

        let steps = Math.max(1, Math.ceil(total / STEP_SIZE));
        if (steps > 1 && iteration === 1) {
            poolMaxDebounces *= steps;

            log('Found a large number of attributes, increasing timeout to ' + (poolMaxDebounces * POOL_DEBOUNCE / 1000 / 60) + ' minutes')
        }

        await new Promise(resolve => setTimeout(resolve, POOL_DEBOUNCE));

        return await awaitPools.wipeAttributes(
            databaseId,
            collectionId,
            iteration + 1
        );
    },
    wipeIndexes: async (databaseId, collectionId, iteration = 1) => {
        if (iteration > poolMaxDebounces) {
            return false;
        }

        const { total } = await databasesListIndexes({
            databaseId,
            collectionId,
            queries: [JSON.stringify({ method: 'limit', values: [1] })],
            parseOutput: false
        });

        if (total === 0) {
            return true;
        }

        let steps = Math.max(1, Math.ceil(total / STEP_SIZE));
        if (steps > 1 && iteration === 1) {
            poolMaxDebounces *= steps;

            log('Found a large number of indexes, increasing timeout to ' + (poolMaxDebounces * POOL_DEBOUNCE / 1000 / 60) + ' minutes')
        }

        await new Promise(resolve => setTimeout(resolve, POOL_DEBOUNCE));

        return await awaitPools.wipeIndexes(
            databaseId,
            collectionId,
            iteration + 1
        );
    },
    wipeVariables: async (functionId, iteration = 1) => {
        if (iteration > poolMaxDebounces) {
            return false;
        }

        const { total } = await functionsListVariables({
            functionId,
            queries: ['limit(1)'],
            parseOutput: false
        });

        if (total === 0) {
            return true;
        }

        let steps = Math.max(1, Math.ceil(total / STEP_SIZE));
        if (steps > 1 && iteration === 1) {
            poolMaxDebounces *= steps;

            log('Found a large number of variables, increasing timeout to ' + (poolMaxDebounces * POOL_DEBOUNCE / 1000 / 60) + ' minutes')
        }

        await new Promise(resolve => setTimeout(resolve, POOL_DEBOUNCE));

        return await awaitPools.wipeVariables(
            functionId,
            iteration + 1
        );
    },
    expectAttributes: async (databaseId, collectionId, attributeKeys, iteration = 1) => {
        if (iteration > poolMaxDebounces) {
            return false;
        }

        let steps = Math.max(1, Math.ceil(attributeKeys.length / STEP_SIZE));
        if (steps > 1 && iteration === 1) {
            poolMaxDebounces *= steps;

            log('Creating a large number of attributes, increasing timeout to ' + (poolMaxDebounces * POOL_DEBOUNCE / 1000 / 60) + ' minutes')
        }

        const { attributes } = await paginate(databasesListAttributes, {
            databaseId,
            collectionId,
            parseOutput: false
        }, 100, 'attributes');

        const ready = attributes
            .filter(attribute => {
                if (attributeKeys.includes(attribute.key)) {
                    if (['stuck', 'failed'].includes(attribute.status)) {
                        throw new Error(`Attribute '${attribute.key}' failed!`);
                    }

                    return attribute.status === 'available';
                }

                return false;
            })
            .map(attribute => attribute.key);

        if (ready.length === attributeKeys.length) {
            return true;
        }

        await new Promise(resolve => setTimeout(resolve, POOL_DEBOUNCE));

        return await awaitPools.expectAttributes(
            databaseId,
            collectionId,
            attributeKeys,
            iteration + 1
        );
    },
    expectIndexes: async (databaseId, collectionId, indexKeys, iteration = 1) => {
        if (iteration > poolMaxDebounces) {
            return false;
        }

        let steps = Math.max(1, Math.ceil(indexKeys.length / STEP_SIZE));
        if (steps > 1 && iteration === 1) {
            poolMaxDebounces *= steps;

            log('Creating a large number of indexes, increasing timeout to ' + (poolMaxDebounces * POOL_DEBOUNCE / 1000 / 60) + ' minutes')
        }

        const { indexes } = await paginate(databasesListIndexes, {
            databaseId,
            collectionId,
            parseOutput: false
        }, 100, 'indexes');

        const ready = indexes
            .filter((index) => {
                if (indexKeys.includes(index.key)) {
                    if (['stuck', 'failed'].includes(index.status)) {
                        throw new Error(`Index '${index.key}' failed!`);
                    }

                    return index.status === 'available';
                }

                return false;
            })
            .map(index => index.key);

        if (ready.length >= indexKeys.length) {
            return true;
        }

        await new Promise(resolve => setTimeout(resolve, POOL_DEBOUNCE));

        return await awaitPools.expectIndexes(
            databaseId,
            collectionId,
            indexKeys,
            iteration + 1
        );
    },
}

const pushResources = async ({ all, yes } = {}) => {
    const actions = {
        functions: pushFunction,
        collections: pushCollection,
        buckets: pushBucket,
        teams: pushTeam,
        messages: pushMessagingTopic
    }

    if (all) {
        Object.values(actions).forEach(action => action({ all: true, yes }));
    } else {
        const answers = await inquirer.prompt(questionsPushResources[0]);
        answers.resources.forEach((resource) => {
            const action = actions[resource];
            if (action !== undefined) {
                action({ all: true, yes });
            }
        })
    }
};

const pushFunction = async ({ functionId, all, yes } = {}) => {
    let response = {};

    const functionIds = [];

    if (functionId) {
        functionIds.push(functionId);
    } else if (all) {
        const functions = localConfig.getFunctions();
        if (functions.length === 0) {
            throw new Error("No functions found in the current directory.");
        }
        functionIds.push(...functions.map((func, idx) => {
            return func.$id;
        }));
    }

    if (functionIds.length <= 0) {
        const answers = await inquirer.prompt(questionsPushFunctions[0]);
        functionIds.push(...answers.functions);
    }

    let functions = functionIds.map((id) => {
        const functions = localConfig.getFunctions();
        const func = functions.find((f) => f.$id === id);

        if (!func) {
            throw new Error("Function '" + id + "' not found.")
        }

        return func;
    });

    for (let func of functions) {
        log(`Pushing function ${func.name} ( ${func['$id']} )`)

        try {
            response = await functionsGet({
                functionId: func['$id'],
                parseOutput: false,
            });

            if (response.runtime !== func.runtime) {
                throw new Error(`Runtime missmatch! (local=${func.runtime},remote=${response.runtime}) Please delete remote function or update your appwrite.json`);
            }

            response = await functionsUpdate({
                functionId: func['$id'],
                name: func.name,
                execute: func.execute,
                events: func.events,
                schedule: func.schedule,
                timeout: func.timeout,
                enabled: func.enabled,
                logging: func.logging,
                entrypoint: func.entrypoint,
                commands: func.commands,
                vars: JSON.stringify(response.vars),
                parseOutput: false
            });
        } catch (e) {
            if (e.code == 404) {
                log(`Function ${func.name} ( ${func['$id']} ) does not exist in the project. Creating ... `);
                response = await functionsCreate({
                    functionId: func.$id || 'unique()',
                    name: func.name,
                    runtime: func.runtime,
                    execute: func.execute,
                    events: func.events,
                    schedule: func.schedule,
                    timeout: func.timeout,
                    enabled: func.enabled,
                    logging: func.logging,
                    entrypoint: func.entrypoint,
                    commands: func.commands,
                    vars: JSON.stringify(func.vars),
                    parseOutput: false
                });

                localConfig.updateFunction(func['$id'], {
                    "$id": response['$id'],
                });

                func["$id"] = response['$id'];
                log(`Function ${func.name} created.`);
            } else {
                throw e;
            }
        }

        if (func.variables) {
            // Delete existing variables

            const { total } = await functionsListVariables({
                functionId: func['$id'],
                queries: [JSON.stringify({ method: 'limit', values: [1] })],
                parseOutput: false
            });

            let pushVariables = yes;

            if (total === 0) {
                pushVariables = true;
            } else if (total > 0 && !yes) {
                const variableAnswers = await inquirer.prompt(questionsPushFunctions[1])
                pushVariables = variableAnswers.override.toLowerCase() === "yes";
            }

            if (!pushVariables) {
                log(`Skipping variables for ${func.name} ( ${func['$id']} )`);
            } else {
                log(`Pushing variables for ${func.name} ( ${func['$id']} )`);

                const { variables } = await paginate(functionsListVariables, {
                    functionId: func['$id'],
                    parseOutput: false
                }, 100, 'variables');

                await Promise.all(variables.map(async variable => {
                    await functionsDeleteVariable({
                        functionId: func['$id'],
                        variableId: variable['$id'],
                        parseOutput: false
                    });
                }));

                let result = await awaitPools.wipeVariables(func['$id']);
                if (!result) {
                    throw new Error("Variable deletion timed out.");
                }

                // Push local variables
                await Promise.all(Object.keys(func.variables).map(async localVariableKey => {
                    await functionsCreateVariable({
                        functionId: func['$id'],
                        key: localVariableKey,
                        value: func.variables[localVariableKey],
                        parseOutput: false
                    });
                }));
            }
        }

        // Create tag
        if (!func.entrypoint) {
            const answers = await inquirer.prompt(questionsGetEntrypoint)
            func.entrypoint = answers.entrypoint;
            localConfig.updateFunction(func['$id'], func);
        }

        try {
            response = await functionsCreateDeployment({
                functionId: func['$id'],
                entrypoint: func.entrypoint,
                commands: func.commands,
                code: func.path,
                activate: true,
                parseOutput: false
            })

            success(`Pushed ${func.name} ( ${func['$id']} )`);

        } catch (e) {
            switch (e.code) {
                case 'ENOENT':
                    error(`Function ${func.name} ( ${func['$id']} ) not found in the current directory. Skipping ...`);
                    break;
                default:
                    throw e;
            }
        }
    }

    success(`Pushed ${functions.length} functions`);
}

const createAttribute = async (databaseId, collectionId, attribute) => {
    switch (attribute.type) {
        case 'string':
            switch (attribute.format) {
                case 'email':
                    return await databasesCreateEmailAttribute({
                        databaseId,
                        collectionId,
                        key: attribute.key,
                        required: attribute.required,
                        xdefault: attribute.default,
                        array: attribute.array,
                        parseOutput: false
                    })
                case 'url':
                    return await databasesCreateUrlAttribute({
                        databaseId,
                        collectionId,
                        key: attribute.key,
                        required: attribute.required,
                        xdefault: attribute.default,
                        array: attribute.array,
                        parseOutput: false
                    })
                case 'ip':
                    return await databasesCreateIpAttribute({
                        databaseId,
                        collectionId,
                        key: attribute.key,
                        required: attribute.required,
                        xdefault: attribute.default,
                        array: attribute.array,
                        parseOutput: false
                    })
                case 'enum':
                    return await databasesCreateEnumAttribute({
                        databaseId,
                        collectionId,
                        key: attribute.key,
                        elements: attribute.elements,
                        required: attribute.required,
                        xdefault: attribute.default,
                        array: attribute.array,
                        parseOutput: false
                    })
                default:
                    return await databasesCreateStringAttribute({
                        databaseId,
                        collectionId,
                        key: attribute.key,
                        size: attribute.size,
                        required: attribute.required,
                        xdefault: attribute.default,
                        array: attribute.array,
                        parseOutput: false
                    })

            }
        case 'integer':
            return await databasesCreateIntegerAttribute({
                databaseId,
                collectionId,
                key: attribute.key,
                required: attribute.required,
                min: attribute.min,
                max: attribute.max,
                xdefault: attribute.default,
                array: attribute.array,
                parseOutput: false
            })
        case 'double':
            return databasesCreateFloatAttribute({
                databaseId,
                collectionId,
                key: attribute.key,
                required: attribute.required,
                min: attribute.min,
                max: attribute.max,
                xdefault: attribute.default,
                array: attribute.array,
                parseOutput: false
            })
        case 'boolean':
            return databasesCreateBooleanAttribute({
                databaseId,
                collectionId,
                key: attribute.key,
                required: attribute.required,
                xdefault: attribute.default,
                array: attribute.array,
                parseOutput: false
            })
        case 'datetime':
            return databasesCreateDatetimeAttribute({
                databaseId,
                collectionId,
                key: attribute.key,
                required: attribute.required,
                xdefault: attribute.default,
                array: attribute.array,
                parseOutput: false
            })
        case 'relationship':
            return databasesCreateRelationshipAttribute({
                databaseId,
                collectionId,
                relatedCollectionId: attribute.relatedCollection,
                type: attribute.relationType,
                twoWay: attribute.twoWay,
                key: attribute.key,
                twoWayKey: attribute.twoWayKey,
                onDelete: attribute.onDelete,
                parseOutput: false
            })
    }
}

const pushCollection = async ({ all, yes } = {}) => {
    let response = {};

    const collections = [];

    if (all) {
        if (localConfig.getCollections().length === 0) {
            throw new Error("No collections found in the current directory. Run `{{ language.params.executableName }} pull collection` to fetch all your collections.");
        }
        collections.push(...localConfig.getCollections());
    } else {
        const answers = await inquirer.prompt(questionsPushCollections[0])
        const configCollections = new Map();
        localConfig.getCollections().forEach((c) => {
            configCollections.set(`${c['databaseId']}|${c['$id']}`, c);
        });
        answers.collections.forEach((a) => {
            const collection = configCollections.get(a);
            collections.push(collection);
        })
    }

    for (let collection of collections) {
        log(`Pushing collection ${collection.name} ( ${collection['databaseId']} - ${collection['$id']} )`)

        let databaseId;

        const localDatabase = localConfig.getDatabase(collection.databaseId);

        try {
            const database = await databasesGet({
                databaseId: collection.databaseId,
                parseOutput: false,
            });

            databaseId = database.$id;

            if (database.name !== (localDatabase.name ?? collection.databaseId)) {
                await databasesUpdate({
                    databaseId: collection.databaseId,
                    name: localDatabase.name ?? collection.databaseId,
                    parseOutput: false
                })

                success(`Updated ${localDatabase.name} ( ${collection.databaseId} )`);
            }
        } catch (err) {
            log(`Database ${collection.databaseId} not found. Creating it now...`);

            const database = await databasesCreate({
                databaseId: collection.databaseId,
                name: localDatabase.name ?? collection.databaseId,
                parseOutput: false,
            });

            databaseId = database.$id;
        }

        try {
            response = await databasesGetCollection({
                databaseId,
                collectionId: collection['$id'],
                parseOutput: false,
            })

            log(`Collection ${collection.name} ( ${collection['$id']} ) already exists.`);

            if (!yes) {
                const answers = await inquirer.prompt(questionsPushCollections[1])
                if (answers.override.toLowerCase() !== "yes") {
                    log(`Received "${answers.override}". Skipping ${collection.name} ( ${collection['$id']} )`);
                    continue;
                }
            }

            log(`Deleting indexes and attributes ... `);

            const { indexes } = await paginate(databasesListIndexes, {
                databaseId,
                collectionId: collection['$id'],
                parseOutput: false
            }, 100, 'indexes');

            await Promise.all(indexes.map(async index => {
                await databasesDeleteIndex({
                    databaseId,
                    collectionId: collection['$id'],
                    key: index.key,
                    parseOutput: false
                });
            }));

            let result = await awaitPools.wipeIndexes(databaseId, collection['$id']);
            if (!result) {
                throw new Error("Index deletion timed out.");
            }

            const { attributes } = await paginate(databasesListAttributes, {
                databaseId,
                collectionId: collection['$id'],
                parseOutput: false
            }, 100, 'attributes');

            await Promise.all(attributes.map(async attribute => {
                await databasesDeleteAttribute({
                    databaseId,
                    collectionId: collection['$id'],
                    key: attribute.key,
                    parseOutput: false
                });
            }));

            const deleteAttributesPoolStatus = await awaitPools.wipeAttributes(databaseId, collection['$id']);
            if (!deleteAttributesPoolStatus) {
                throw new Error("Attribute deletion timed out.");
            }

            await databasesUpdateCollection({
                databaseId,
                collectionId: collection['$id'],
                name: collection.name,
                documentSecurity: collection.documentSecurity,
                permissions: collection['$permissions'],
                enabled: collection.enabled,
                parseOutput: false
            })
        } catch (e) {
            if (e.code == 404) {
                log(`Collection ${collection.name} does not exist in the project. Creating ... `);
                response = await databasesCreateCollection({
                    databaseId,
                    collectionId: collection['$id'],
                    name: collection.name,
                    documentSecurity: collection.documentSecurity,
                    permissions: collection['$permissions'],
                    parseOutput: false
                })

            } else {
                throw e;
            }
        }

        // Create all non-relationship attributes first
        const attributes = collection.attributes.filter(attribute => attribute.type !== 'relationship');

        await Promise.all(attributes.map(attribute => {
            return createAttribute(databaseId, collection['$id'], attribute);
        }));

        let result = await awaitPools.expectAttributes(
            databaseId,
            collection['$id'],
            attributes.map(attribute => attribute.key)
        );

        if (!result) {
            throw new Error("Attribute creation timed out.");
        }

        success(`Created ${attributes.length} non-relationship attributes`);

        log(`Creating indexes ...`)

        await Promise.all(collection.indexes.map(async index => {
            await databasesCreateIndex({
                databaseId,
                collectionId: collection['$id'],
                key: index.key,
                type: index.type,
                attributes: index.attributes,
                orders: index.orders,
                parseOutput: false
            });
        }));

        result = await awaitPools.expectIndexes(
            databaseId,
            collection['$id'],
            collection.indexes.map(attribute => attribute.key)
        );

        if (!result) {
            throw new Error("Index creation timed out.");
        }

        success(`Created ${collection.indexes.length} indexes`);

        success(`Pushed ${collection.name} ( ${collection['$id']} )`);
    }

    // Create the relationship attributes
    for (let collection of collections) {
        const relationships = collection.attributes.filter(attribute =>
            attribute.type === 'relationship' && attribute.side === 'parent'
        );

        if (relationships.length === 0) {
            continue;
        }

        log(`Pushing relationships for collection ${collection.name} ( ${collection['$id']} )`);

        await Promise.all(relationships.map(attribute => {
            return createAttribute(collection['databaseId'], collection['$id'], attribute);
        }));

        let result = await awaitPools.expectAttributes(
            collection['databaseId'],
            collection['$id'],
            relationships.map(attribute => attribute.key)
        );

        if (!result) {
            throw new Error("Attribute creation timed out.");
        }

        success(`Created ${relationships.length} relationship attributes`);
    }
}

const pushBucket = async ({ all, yes } = {}) => {
    let response = {};

    let bucketIds = [];
    const configBuckets = localConfig.getBuckets();

    if (all) {
        if (configBuckets.length === 0) {
            throw new Error("No buckets found in the current directory. Run `appwrite pull bucket` to fetch all your buckets.");
        }
        bucketIds.push(...configBuckets.map((b) => b.$id));
    }

    if (bucketIds.length === 0) {
        const answers = await inquirer.prompt(questionsPushBuckets[0])
        bucketIds.push(...answers.buckets);
    }

    let buckets = [];

    for (const bucketId of bucketIds) {
        const idBuckets = configBuckets.filter((b) => b.$id === bucketId);
        buckets.push(...idBuckets);
    }

    for (let bucket of buckets) {
        log(`Pushing bucket ${bucket.name} ( ${bucket['$id']} )`)

        try {
            response = await storageGetBucket({
                bucketId: bucket['$id'],
                parseOutput: false,
            })
            log(`Bucket ${bucket.name} ( ${bucket['$id']} ) already exists.`);

            if (!yes) {
                const answers = await inquirer.prompt(questionsPushBuckets[1])
                if (answers.override.toLowerCase() !== "yes") {
                    log(`Received "${answers.override}". Skipping ${bucket.name} ( ${bucket['$id']} )`);
                    continue;
                }
            }

            log(`Updating bucket ...`)

            await storageUpdateBucket({
                bucketId: bucket['$id'],
                name: bucket.name,
                permissions: bucket['$permissions'],
                fileSecurity: bucket.fileSecurity,
                enabled: bucket.enabled,
                maximumFileSize: bucket.maximumFileSize,
                allowedFileExtensions: bucket.allowedFileExtensions,
                compression: bucket.compression,
                encryption: bucket.encryption,
                antivirus: bucket.antivirus,
                compression: bucket.compression,
                parseOutput: false
            });

            success(`Pushed ${bucket.name} ( ${bucket['$id']} )`);
        } catch (e) {
            if (e.code == 404) {
                log(`Bucket ${bucket.name} does not exist in the project. Creating ... `);

                response = await storageCreateBucket({
                    bucketId: bucket['$id'],
                    name: bucket.name,
                    permissions: bucket['$permissions'],
                    fileSecurity: bucket.fileSecurity,
                    enabled: bucket.enabled,
                    maximumFileSize: bucket.maximumFileSize,
                    allowedFileExtensions: bucket.allowedFileExtensions,
                    compression: bucket.compression,
                    encryption: bucket.encryption,
                    antivirus: bucket.antivirus,
                    parseOutput: false
                })

                success(`Pushed ${bucket.name} ( ${bucket['$id']} )`);
            } else {
                throw e;
            }
        }
    }
}

const pushTeam = async ({ all, yes } = {}) => {
    let response = {};

    let teamIds = [];
    const configTeams = localConfig.getTeams();

    if (all) {
        if (configTeams.length === 0) {
            throw new Error("No teams found in the current directory. Run `appwrite pull team` to fetch all your teams.");
        }
        teamIds.push(...configTeams.map((t) => t.$id));
    }

    if (teamIds.length === 0) {
        const answers = await inquirer.prompt(questionsPushTeams[0])
        teamIds.push(...answers.teams);
    }

    let teams = [];

    for (const teamId of teamIds) {
        const idTeams = configTeams.filter((t) => t.$id === teamId);
        teams.push(...idTeams);
    }

    for (let team of teams) {
        log(`Pushing team ${team.name} ( ${team['$id']} )`)

        try {
            response = await teamsGet({
                teamId: team['$id'],
                parseOutput: false,
            })
            log(`Team ${team.name} ( ${team['$id']} ) already exists.`);

            if (!yes) {
                const answers = await inquirer.prompt(questionsPushTeams[1])
                if (answers.override.toLowerCase() !== "yes") {
                    log(`Received "${answers.override}". Skipping ${team.name} ( ${team['$id']} )`);
                    continue;
                }
            }

            log(`Updating team ...`)

            await teamsUpdate({
                teamId: team['$id'],
                name: team.name,
                parseOutput: false
            });

            success(`Pushed ${team.name} ( ${team['$id']} )`);
        } catch (e) {
            if (e.code == 404) {
                log(`Team ${team.name} does not exist in the project. Creating ... `);

                response = await teamsCreate({
                    teamId: team['$id'],
                    name: team.name,
                    parseOutput: false
                })

                success(`Pushed ${team.name} ( ${team['$id']} )`);
            } else {
                throw e;
            }
        }
    }
}

const pushMessagingTopic = async ({ all, yes } = {}) => {
    let response = {};

    let topicsIds = [];
    const configTopics = localConfig.getMessagingTopics();
    let overrideExisting = yes;

    if (all) {
        if (configTopics.length === 0) {
            throw new Error("No topics found in the current directory. Run `appwrite pull topics` to pull all your messaging topics.");
        }
        topicsIds.push(...configTopics.map((b) => b.$id));
    }

    if (topicsIds.length === 0) {
        const answers = await inquirer.prompt(questionsPushMessagingTopics[0])
        topicsIds.push(...answers.topics);
    }

    let topics = [];

    for (const topicId of topicsIds) {
        const idTopic = configTopics.filter((b) => b.$id === topicId);
        topics.push(...idTopic);
    }

    if (!yes) {
        const answers = await inquirer.prompt(questionsPushMessagingTopics[1])
        if (answers.override.toLowerCase() === "yes") {
            overrideExisting = true;
        }
    }

    for (let topic of topics) {
        log(`Pushing topic ${topic.name} ( ${topic['$id']} )`)

        try {
            response = await messagingGetTopic({
                topicId: topic['$id'],
                parseOutput: false
            })
            log(`Topic ${topic.name} ( ${topic['$id']} ) already exists.`);

            if (!overrideExisting) {
                log(`Skipping ${topic.name} ( ${topic['$id']} )`);
                continue;
            }

            log(`Updating Topic ...`)

            await messagingUpdateTopic({
                topicId: topic['$id'],
                name: topic.name,
                subscribe: topic.subscribe,
                parseOutput: false
            });

            success(`Pushed ${topic.name} ( ${topic['$id']} )`);
        } catch (e) {
            if (e.code == 404) {
                log(`Topic ${topic.name} does not exist in the project. Creating ... `);

                response = await messagingCreateTopic({
                    topicId: topic['$id'],
                    name: topic.name,
                    subscribe: topic.subscribe,
                    parseOutput: false
                })

                success(`Pushed ${topic.name} ( ${topic['$id']} )`);
            } else {
                throw e;
            }
        }
    }
}

const push = new Command("push")
    .description(commandDescriptions['push'])
    .option(`--all`, `Flag to push all resources`)
    .option(`--yes`, `Flag to confirm all warnings`)
    .action(actionRunner(pushResources));

push
    .command("function")
    .description("Push functions in the current directory.")
    .option(`--functionId <functionId>`, `Function ID`)
    .option(`--all`, `Flag to push all functions`)
    .option(`--yes`, `Flag to confirm all warnings`)
    .action(actionRunner(pushFunction));

push
    .command("collection")
    .description("Push collections in the current project.")
    .option(`--all`, `Flag to push all collections`)
    .option(`--yes`, `Flag to confirm all warnings`)
    .action(actionRunner(pushCollection));

push
    .command("bucket")
    .description("Push buckets in the current project.")
    .option(`--all`, `Flag to push all buckets`)
    .option(`--yes`, `Flag to confirm all warnings`)
    .action(actionRunner(pushBucket));

push
    .command("team")
    .description("Push teams in the current project.")
    .option(`--all`, `Flag to push all teams`)
    .option(`--yes`, `Flag to confirm all warnings`)
    .action(actionRunner(pushTeam));

push
    .command("topic")
    .description("Push messaging topics in the current project.")
    .option(`--all`, `Flag to deploy all topics`)
    .option(`--yes`, `Flag to confirm all warnings`)
    .action(actionRunner(pushMessagingTopic));

module.exports = {
    push
}
