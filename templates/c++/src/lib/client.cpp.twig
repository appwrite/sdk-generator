
#include "client.hpp"
#include "include/exception.hpp"

using string = std::string;
using json = nlohmann::json;

namespace {{ spec.title | caseUcfirst }} {

/**
 * SDK constructor.
 */
Client::Client() { }

/**
 * SDK destructor
 */
Client::~Client() {
    // TODO?
}

{% for header in spec.global.headers %}
/**
 * Set {{header.key | caseUcfirst}}
 *
{% if header.description %}
 * {{header.description}}
 *
{% endif %}
 * @param string value
 *
 * @return Client
 */
Client& Client::set{{header.key | caseUcfirst}}(string value) {
    this->addHeader("{{header.name}}", value);
    return *this;
}

{% endfor %}
/***
 * @param bool status
 * @return *this
 */
Client& Client::setSelfSigned(bool status) {
    this->selfSigned = status;
    return *this;
}

/***
 * @param endpoint
 * @return *this
 */
Client& Client::setEndpoint(string endpoint) {
    this->endpoint = endpoint;
    return *this;
}

/**
 * @param key
 * @param value
 * @return *this
 */
Client& Client::addHeader(string key, string value) {
    string keyLower = key;
    std::transform(keyLower.begin(), keyLower.end(), keyLower.begin(), ::tolower);
    this->headers[keyLower] = value;
    return *this;
}

/**
 * Call
 *
 * Make an API call
 *
 * @param string method
 * @param string path
 * @param array params
 * @param array headers
 * @return array|string  // TODO: Returning JSON (instead of array), but not string.
 * @throws {{spec.title | caseUcfirst}}Exception
 */
json Client::call(string method, string path, cpr::Header headers, cpr::Payload params) {
  //  return json({{ "{{" }}"fake response", "will fix soon (TM)" {{ "}}" }});

  
        cpr::Url url = cpr::Url{this->endpoint + path};

        cpr::Response responseHeaders;
        int responseStatus = -1;
        string responseType;
        string responseBody;
        if (method == "METHOD_GET")
        {
            responseHeaders = cpr::Get(url,
                                       params,
                                       headers,
                                       cpr::VerifySsl{!this->selfSigned});
        }
        else if (method == "METHOD_POST")
        {
            responseHeaders = cpr::Post(url,
                                        params,
                                        headers,
                                        cpr::VerifySsl{!this->selfSigned});
        }
        else if (method == "METHOD_PUT")
        {
            responseHeaders = cpr::Put(url,
                                      params,
                                      headers,
                                       cpr::VerifySsl{!this->selfSigned});
        }
        else if (method == "METHOD_DELETE")
        {
            responseHeaders = cpr::Delete(url,
                                          params,
                                         headers,
                                          cpr::VerifySsl{!this->selfSigned});
        }
        else
        {
            throw AppwriteException("Invalid method");
        }
        return json::parse(responseHeaders.text);
    
/*
    ch = curl_init(this->endpoint + path + ((method == self::METHOD_GET && !empty(params)) ? "?" . http_build_query(params) : ""));
    json responseHeaders;
    int responseStatus = -1;
    string responseType;
    string responseBody;

    // Merge header parameters into Client's existing headers, overwriting any collisions
    json call_headers(this->headers);
    call_headers.merge_patch(headers);

    switch (headers["content-type"]) {
        case "application/json":
            query = json_encode(params);
            break;

        case "multipart/form-data":
            query = ((json) params).flatten();
            break;

        default:
            query = http_build_query(params);
            break;
    }

    foreach(headers as i => header) {
        headers[] = i . ":" . header;
        unset(headers[i]);
    }

    curl_setopt(ch, CURLOPT_CUSTOMREQUEST, method);
    curl_setopt(ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt(ch, CURLOPT_USERAGENT, php_uname("s") . "-" . php_uname("r") . ":{{ language.name | caseLower }}-" . phpversion());
    curl_setopt(ch, CURLOPT_HTTPHEADER, headers);
    curl_setopt(ch, CURLOPT_FOLLOWLOCATION, true);
    curl_setopt(ch, CURLOPT_HEADERFUNCTION, function(curl, header) use (&responseHeaders) {
        len = strlen(header);
        header = explode(":", strtolower(header), 2);

        if (count(header) < 2) { // ignore invalid headers
            return len;
        }

        responseHeaders[strtolower(trim(header[0]))] = trim(header[1]);

        return len;
    });

    if (method != self::METHOD_GET) {
        curl_setopt(ch, CURLOPT_POSTFIELDS, query);
    }

    // Allow self signed certificates
    if (this->selfSigned) {
        curl_setopt(ch, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt(ch, CURLOPT_SSL_VERIFYPEER, false);
    }

    responseBody   = curl_exec(ch);
    responseType   = responseHeaders["content-type"] ?? "";
    responseStatus = curl_getinfo(ch, CURLINFO_HTTP_CODE);

    switch (substr(responseType, 0, strpos(responseType, ";"))) {
        case "application/json":
            responseBody = json_decode(responseBody, true);
        break;
    }

    if (curl_errno(ch)) {
        throw new {{spec.title | caseUcfirst}}Exception(curl_error(ch), responseStatus, responseBody);
    }

    curl_close(ch);

    if (responseStatus >= 400) {
        if (is_array(responseBody)) {
            throw new {{spec.title | caseUcfirst}}Exception(responseBody["message"], responseStatus, responseBody);
        } else {
            throw new {{spec.title | caseUcfirst}}Exception(responseBody, responseStatus);
        }
    }


    return responseBody;
*/
}
} // namespace Appwrite
