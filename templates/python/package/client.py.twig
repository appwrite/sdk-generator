import io
import json
import os
import platform
import requests
from .input_file import InputFile
from .exception import {{spec.title | caseUcfirst}}Exception
from .encoders.value_class_encoder import ValueClassEncoder

class Client:
    def __init__(self):
        self._chunk_size = 5*1024*1024
        self._self_signed = False
        self._endpoint = '{{spec.endpoint}}'
        self._global_headers = {
            'content-type': '',
            'user-agent' : f'{{spec.title | caseUcfirst}}{{ language.name | caseUcfirst }}SDK/{{ sdk.version }} ({platform.uname().system}; {platform.uname().version}; {platform.uname().machine})',
            'x-sdk-name': '{{ sdk.name }}',
            'x-sdk-platform': '{{ sdk.platform }}',
            'x-sdk-language': '{{ language.name | caseLower }}',
            'x-sdk-version': '{{ sdk.version }}',
{% for key,header in spec.global.defaultHeaders %}
            '{{key}}' : '{{header}}',
{% endfor %}
        }

    @staticmethod
    def _is_explicitly_null(value):
        """Helper method to distinguish between None (undefined) and explicit null values"""
        # Check if value is a special marker indicating an explicit null
        return isinstance(value, type('NullValue', (), {'is_null': True}))

    @staticmethod
    def null():
        """Helper method to create an explicit null value to be sent to the API
        Use this when you want to explicitly set a field to null, as opposed to 
        not sending the field at all (which happens when you use None)"""
        return type('NullValue', (), {'is_null': True})()

    def set_self_signed(self, status=True):
        self._self_signed = status
        return self

    def set_endpoint(self, endpoint):
        if not endpoint.startswith('http://') and not endpoint.startswith('https://'):
            raise {{spec.title | caseUcfirst}}Exception('Invalid endpoint URL: ' + endpoint)

        self._endpoint = endpoint
        return self

    def add_header(self, key, value):
        self._global_headers[key.lower()] = value
        return self
{% for header in spec.global.headers %}

    def set_{{header.key | caseSnake}}(self, value):
{% if header.description %}
        """{{header.description}}"""

{% endif %}
        self._global_headers['{{header.name|lower}}'] = value
        return self
{% endfor %}

    def call(self, method, path='', headers=None, params=None, nullable_params=None, response_type='json'):
        if headers is None:
            headers = {}

        if params is None:
            params = {}
            
        if nullable_params is None:
            nullable_params = []

        # Process headers and params to handle explicit nulls while removing undefined (None) values
        headers = {k: v for k, v in headers.items() if v is not None or self._is_explicitly_null(v)}
        params = {k: v for k, v in params.items() if v is not None or self._is_explicitly_null(v) or k in nullable_params}

        # Replace explicit null markers with None for JSON serialization
        headers = {k: None if self._is_explicitly_null(v) else v for k, v in headers.items()}
        params = {k: None if self._is_explicitly_null(v) or (v is None and k in nullable_params) else v for k, v in params.items()}

        # Merge with global headers
        headers = {**self._global_headers, **headers}

        data = {}
        files = {}
        stringify = False

        # Move params to data for non-GET requests
        if method != 'get':
            data = params
            params = {}

        # Handle JSON content
        if headers['content-type'].startswith('application/json'):
            data = json.dumps(data, cls=ValueClassEncoder)

        # Handle multipart form data
        if headers['content-type'].startswith('multipart/form-data'):
            del headers['content-type']
            stringify = True
            for key in data.copy():
                if isinstance(data[key], InputFile):
                    files[key] = (data[key].filename, data[key].data)
                    del data[key]
            data = self.flatten(data, stringify=stringify)

        # Make the HTTP request
        response = None
        try:
            response = requests.request(
                method=method,
                url=self._endpoint + path,
                params=self.flatten(params, stringify=stringify),
                data=data,
                files=files,
                headers=headers,
                verify=(not self._self_signed),
                allow_redirects=False if response_type == 'location' else True
            )

            response.raise_for_status()

            # Handle warnings
            warnings = response.headers.get('x-{{ spec.title | lower }}-warning')
            if warnings:
                for warning in warnings.split(';'):
                    print(f'Warning: {warning}')

            content_type = response.headers['Content-Type']

            # Handle different response types
            if response_type == 'location':
                return response.headers.get('Location')

            if content_type.startswith('application/json'):
                return response.json()

            return response._content

        except Exception as e:
            if response is not None:
                content_type = response.headers['Content-Type']
                if content_type.startswith('application/json'):
                    raise {{spec.title | caseUcfirst}}Exception(response.json()['message'], response.status_code, response.json().get('type'), response.text)
                else:
                    raise {{spec.title | caseUcfirst}}Exception(response.text, response.status_code, None, response.text)
            else:
                raise {{spec.title | caseUcfirst}}Exception(e)

    def chunked_upload(
        self,
        path,
        headers = None,
        params = None,
        param_name = '',
        on_progress = None,
        upload_id = ''
    ):
        input_file = params[param_name]

        if input_file.source_type == 'path':
            size = os.stat(input_file.path).st_size
            input = open(input_file.path, 'rb')
        elif input_file.source_type == 'bytes':
            size = len(input_file.data)
            input = input_file.data

        if size < self._chunk_size:
            if input_file.source_type == 'path':
                input_file.data = input.read()

            params[param_name] = input_file
            return self.call(
                'post',
                path,
                headers,
                params
            )

        offset = 0
        counter = 0

        try:
            result = self.call('get', path + '/' + upload_id, headers)
            counter = result['chunksUploaded']
        except:
            pass

        if counter > 0:
            offset = counter * self._chunk_size
            input.seek(offset)

        while offset < size:
            if input_file.source_type == 'path':
                input_file.data = input.read(self._chunk_size) or input.read(size - offset)
            elif input_file.source_type == 'bytes':
                if offset + self._chunk_size < size:
                    end = offset + self._chunk_size
                else:
                    end = size
                input_file.data = input[offset:end]

            params[param_name] = input_file
            headers["content-range"] = f'bytes {offset}-{min((offset + self._chunk_size) - 1, size - 1)}/{size}'

            result = self.call(
                'post',
                path,
                headers,
                params,
            )

            offset = offset + self._chunk_size

            if "$id" in result:
                headers["x-{{ spec.title | caseLower }}-id"] = result["$id"]

            if on_progress is not None:
                end = min((((counter * self._chunk_size) + self._chunk_size) - 1), size - 1)
                on_progress({
                    "$id": result["$id"],
                    "progress": min(offset, size)/size * 100,
                    "sizeUploaded": end+1,
                    "chunksTotal": result["chunksTotal"],
                    "chunksUploaded": result["chunksUploaded"],
                })

            counter = counter + 1

        return result

    def flatten(self, data, prefix='', stringify=False):
        """Flatten a nested dictionary/list into a flat dictionary with dot notation."""
        output = {}
        i = 0

        for key in data:
            value = data[key] if isinstance(data, dict) else key
            finalKey = prefix + '[' + key +']' if prefix else key
            finalKey = prefix + '[' + str(i) +']' if isinstance(data, list) else finalKey
            i += 1

            if value is None or self._is_explicitly_null(value):  # Handle null values
                if stringify:
                    output[finalKey] = ''
                else:
                    output[finalKey] = None
            elif isinstance(value, (list, dict)):
                output = {**output, **self.flatten(value, finalKey, stringify)}
            else:
                if stringify:
                    output[finalKey] = str(value)
                else:
                    output[finalKey] = value

        return output
