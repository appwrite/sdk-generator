import { Client, TablesDB, ID, Query, type Models, Permission } from '{{appwriteDep}}';
import type { DatabaseId, DatabaseTables, QueryBuilder } from './types.js';

const createQueryBuilder = <T>(): QueryBuilder<T> => ({
  equal: (field, value) => Query.equal(String(field), value as any),
  notEqual: (field, value) => Query.notEqual(String(field), value as any),
  lessThan: (field, value) => Query.lessThan(String(field), value as any),
  lessThanEqual: (field, value) => Query.lessThanEqual(String(field), value as any),
  greaterThan: (field, value) => Query.greaterThan(String(field), value as any),
  greaterThanEqual: (field, value) => Query.greaterThanEqual(String(field), value as any),
  contains: (field, value) => Query.contains(String(field), value as any),
  search: (field, value) => Query.search(String(field), value),
  isNull: (field) => Query.isNull(String(field)),
  isNotNull: (field) => Query.isNotNull(String(field)),
  startsWith: (field, value) => Query.startsWith(String(field), value),
  endsWith: (field, value) => Query.endsWith(String(field), value),
  between: (field, start, end) => Query.between(String(field), start as any, end as any),
  select: (fields) => Query.select(fields.map(String)),
  orderAsc: (field) => Query.orderAsc(String(field)),
  orderDesc: (field) => Query.orderDesc(String(field)),
  limit: (value) => Query.limit(value),
  offset: (value) => Query.offset(value),
  cursorAfter: (documentId) => Query.cursorAfter(documentId),
  cursorBefore: (documentId) => Query.cursorBefore(documentId),
  or: (...queries) => Query.or(queries),
  and: (...queries) => Query.and(queries),
});

{{{TABLE_ID_MAP}}}

{{{TABLES_WITH_RELATIONSHIPS}}}

function createTableApi<T extends Models.Row>(
  tablesDB: TablesDB,
  databaseId: string,
  tableId: string,
) {
  return {
    create: (data: any, options?: { rowId?: string; permissions?: Permission[]; transactionId?: string }) =>
      tablesDB.createRow<T>({
        databaseId,
        tableId,
        rowId: options?.rowId ?? ID.unique(),
        data,
        permissions: options?.permissions?.map((p) => p.toString()),
        transactionId: options?.transactionId,
      }),
    get: (id: string) =>
      tablesDB.getRow<T>({
        databaseId,
        tableId,
        rowId: id,
      }),
    update: (id: string, data: any, options?: { permissions?: Permission[]; transactionId?: string }) =>
      tablesDB.updateRow<T>({
        databaseId,
        tableId,
        rowId: id,
        data,
        ...(options?.permissions ? { permissions: options.permissions.map((p) => p.toString()) } : {}),
        transactionId: options?.transactionId,
      }),
    delete: async (id: string, options?: { transactionId?: string }) => {
      await tablesDB.deleteRow({
        databaseId,
        tableId,
        rowId: id,
        transactionId: options?.transactionId,
      });
    },
    list: (options?: { queries?: (q: any) => string[] }) =>
      tablesDB.listRows<T>({
        databaseId,
        tableId,
        queries: options?.queries?.(createQueryBuilder<T>()),
      }),{{{BULK_METHODS}}}
  };
}

{{{BULK_CHECK}}}
const hasOwn = (obj: unknown, key: string): boolean =>
  obj != null && Object.prototype.hasOwnProperty.call(obj, key);

function createDatabaseProxy<D extends DatabaseId>(
  tablesDB: TablesDB,
  databaseId: D,
): DatabaseTables[D] {
  const tableApiCache = new Map<string, ReturnType<typeof createTableApi>>();
  const dbMap = tableIdMap[databaseId];

  return new Proxy({} as DatabaseTables[D], {
    get(_target, tableName: string) {
      if (typeof tableName === 'symbol') return undefined;

      if (!tableApiCache.has(tableName)) {
        if (!hasOwn(dbMap, tableName)) return undefined;
        const tableId = dbMap[tableName];

        const api = createTableApi(tablesDB, databaseId, tableId);
        {{{BULK_REMOVAL}}}
        tableApiCache.set(tableName, api);
      }
      return tableApiCache.get(tableName);
    },
    has(_target, tableName: string) {
      return typeof tableName === 'string' && hasOwn(dbMap, tableName);
    },
  });
}

export const createDatabases = (client: Client) => {
  const tablesDB = new TablesDB(client);
  const dbCache = new Map<DatabaseId, DatabaseTables[DatabaseId]>();

  return {
    from: <T extends DatabaseId>(databaseId: T): DatabaseTables[T] => {
      if (!dbCache.has(databaseId)) {
        dbCache.set(databaseId, createDatabaseProxy(tablesDB, databaseId));
      }
      return dbCache.get(databaseId) as DatabaseTables[T];
    },
  };
};
