/** @typedef {import('../attribute').Attribute} Attribute */
const { AttributeType } = require('../attribute');
const { LanguageMeta } = require("./language");
const fs = require('fs');
const path = require('path');

class Dart extends LanguageMeta {
  getPackageName() {
    const pubspecPath = path.join(process.cwd(), 'pubspec.yaml');
    if (fs.existsSync(pubspecPath)) {
        const pubspecContent = fs.readFileSync(pubspecPath, 'utf8');
        const lines = pubspecContent.split('\n');

        const dependenciesIndex = lines.findIndex(line => line.trim() === 'dependencies:');

        if (dependenciesIndex !== -1) {
            const indent = lines[dependenciesIndex].search(/\S|$/);
            const dependencies = [];
            for (let i = dependenciesIndex + 1; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim() === '') continue;

                const lineIndent = line.search(/\S|$/);
                if (lineIndent <= indent && line.trim() !== '') {
                    break;
                }

                dependencies.push(line.trim());
            }

            if (dependencies.some(dep => dep.startsWith('dart_appwrite:'))) {
                return 'dart_appwrite';
            }
            if (dependencies.some(dep => dep.startsWith('appwrite:'))) {
                return 'appwrite';
            }
        }
    }

    return 'appwrite';
  }

  getType(attribute, collections) {
    let type = "";
    switch (attribute.type) {
      case AttributeType.STRING:
      case AttributeType.EMAIL:
      case AttributeType.DATETIME:
        type = "String";
        if (attribute.format === AttributeType.ENUM) {
          type = LanguageMeta.toPascalCase(attribute.key);
        }
        break;
      case AttributeType.INTEGER:
        type = "int";
        break;
      case AttributeType.FLOAT:
        type = "double";
        break;
      case AttributeType.BOOLEAN:
        type = "bool";
        break;
      case AttributeType.RELATIONSHIP:
        const relatedCollection = collections.find(c => c.$id === attribute.relatedCollection);
        if (!relatedCollection) {
          throw new Error(`Related collection with ID '${attribute.relatedCollection}' not found.`);
        }
        type = LanguageMeta.toPascalCase(relatedCollection.name);
        if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') {
          type = `List<${type}>`;
        }
        break;
      default:
        throw new Error(`Unknown attribute type: ${attribute.type}`);
    }
    if (attribute.array) {
      type = `List<${type}>`;
    }
    if (!attribute.required) {
      type += "?";
    }
    return type;
  }

  getTemplate() {
  return `// This file is auto-generated by the Appwrite CLI. 
// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(' ')}\`.
<% const __relatedImportsSeen = new Set();
   const sortedAttributes = collection.attributes.slice().sort((a, b) => {
     if (a.required === b.required) return 0;
     return a.required ? -1 : 1;
   }); -%>
<% const __attrs = sortedAttributes; -%>
<% for (const attribute of __attrs) { -%>
<%   if (attribute.type === '${AttributeType.RELATIONSHIP}') { -%>
<%     const related = collections.find(c => c.$id === attribute.relatedCollection); -%>
<%     if (related && !__relatedImportsSeen.has(toSnakeCase(related.name))) { -%>
import '<%- toSnakeCase(related.name) %>.dart';
<%       __relatedImportsSeen.add(toSnakeCase(related.name)); -%>
<%     } -%>
<%   } -%>
<% } -%>

<% for (const attribute of __attrs) { -%>
<% if (attribute.format === '${AttributeType.ENUM}') { -%>
enum <%- toPascalCase(attribute.key) %> {
<% for (const [index, element] of Object.entries(attribute.elements)) { -%>
  <%- strict ? toCamelCase(element) : element %><% if (index < attribute.elements.length - 1) { -%>,<% } %>
<% } -%>
}

<% } -%>
<% } -%>
class <%= toPascalCase(collection.name) %> {
<% for (const [index, attribute] of Object.entries(__attrs)) { -%>
  <%- getType(attribute, collections) %> <%= strict ? toCamelCase(attribute.key) : attribute.key %>;
<% } -%>

  <%= toPascalCase(collection.name) %>({
  <% for (const [index, attribute] of Object.entries(__attrs)) { -%>
  <% if (attribute.required) { %>required <% } %>this.<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (index < __attrs.length - 1) { -%>,<% } %>
  <% } -%>
});

  factory <%= toPascalCase(collection.name) %>.fromMap(Map<String, dynamic> map) {
    return <%= toPascalCase(collection.name) %>(
<% for (const [index, attribute] of Object.entries(__attrs)) { -%>
  <%= strict ? toCamelCase(attribute.key) : attribute.key %>: <% if (attribute.type === '${AttributeType.STRING}' || attribute.type === '${AttributeType.EMAIL}' || attribute.type === '${AttributeType.DATETIME}') { -%>
<% if (attribute.format === '${AttributeType.ENUM}') { -%>
<% if (attribute.array) { -%>
(map['<%= attribute.key %>'] as List<dynamic>?)?.map((e) => <%- toPascalCase(attribute.key) %>.values.firstWhere((element) => element.name == e)).toList()<% } else { -%>
<% if (!attribute.required) { -%>
map['<%= attribute.key %>'] != null ? <%- toPascalCase(attribute.key) %>.values.where((e) => e.name == map['<%= attribute.key %>']).firstOrNull : null<% } else { -%>
<%- toPascalCase(attribute.key) %>.values.firstWhere((e) => e.name == map['<%= attribute.key %>'])<% } -%>
<% } -%>
<% } else { -%>
<% if (attribute.array) { -%>
List<String>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% if (!attribute.required) { %>?<% } %>.toString()<% } -%>
<% } -%>
<% } else if (attribute.type === '${AttributeType.INTEGER}') { -%>
<% if (attribute.array) { -%>
List<int>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% } -%>
<% } else if (attribute.type === '${AttributeType.FLOAT}') { -%>
<% if (attribute.array) { -%>
List<double>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% } -%>
<% } else if (attribute.type === '${AttributeType.BOOLEAN}') { -%>
<% if (attribute.array) { -%>
List<bool>.from(map['<%= attribute.key %>'] ?? [])<% } else { -%>
map['<%= attribute.key %>']<% } -%>
<% } else if (attribute.type === '${AttributeType.RELATIONSHIP}') { -%>
<% if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') { -%>
(map['<%= attribute.key %>'] as List<dynamic>?)?.map((e) => <%- toPascalCase(collections.find(c => c.$id === attribute.relatedCollection).name) %>.fromMap(e)).toList()
<% } else { -%>
<% if (!attribute.required) { -%>
map['<%= attribute.key %>'] != null ? <%- toPascalCase(collections.find(c => c.$id === attribute.relatedCollection).name) %>.fromMap(map['<%= attribute.key %>']) : null<% } else { -%>
<%- toPascalCase(collections.find(c => c.$id === attribute.relatedCollection).name) %>.fromMap(map['<%= attribute.key %>'])<% } -%>
<% } -%>
<% } -%><% if (index < __attrs.length - 1) { -%>,<% } %>
<% } -%>
    );
  }

  Map<String, dynamic> toMap() {
    return {
<% for (const [index, attribute] of Object.entries(__attrs)) { -%>
  '<%= attribute.key %>': <% if (attribute.type === '${AttributeType.RELATIONSHIP}') { -%>
<% if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.map((e) => e.toMap()).toList()
<% } else { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.toMap()<% } -%>
<% } else if (attribute.format === '${AttributeType.ENUM}') { -%>
<% if (attribute.array) { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.map((e) => e.name).toList()<% } else { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key %><% if (!attribute.required) { %>?<% } %>.name<% } -%>
<% } else { -%>
<%= strict ? toCamelCase(attribute.key) : attribute.key -%>
<% } -%><% if (index < __attrs.length - 1) { -%>,<% } %>
<% } -%>
    };
  }
}
`;
  }

  getFileName(collection) {
    return LanguageMeta.toSnakeCase(collection.name) + ".dart";
  }
}

module.exports = { Dart };