package {{ spec.title | caseLower }}

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/http/cookiejar"
	"crypto/tls"
	"net/url"
	"strings"
	"time"
)

// Client is the client struct to access Appwrite services
type Client struct {
	client     *http.Client
	headers    map[string]string
	endpoint   string
	timeout    time.Duration
	selfSigned bool
}

// NewClient initializes a new Appwrite client with a given timeout
func NewClient(timeout time.Duration) Client {
	headers := map[string]string{
		"content-type": "application/json",
	}
	httpClient, err := getDefaultClient(timeout)
	if err != nil { panic(err) }
	return Client {
		endpoint: "https://appwrite.io/v1",
		client: httpClient,
		timeout: timeout,
	return Client{
		client: &http.Client{
			Timeout: timeout,
		},
		headers: headers,
	}
}

func getDefaultClient(timeout time.Duration) (*http.Client, error) {
	jar, err := cookiejar.New(nil)
	if err != nil { 
		return nil, err 
	}
	return &http.Client {
		Jar: jar,
		Timeout: timeout,
	}, nil
}

// SetEndpoint sets the default endpoint to which the Client connects to
func (clt *Client) SetEndpoint(endpoint string) {
	clt.endpoint = endpoint
}

// SetSelfSigned sets the condition that specify if the Client should allow connections to a server using a self-signed certificate
func (clt *Client) SetSelfSigned(status bool) {
	clt.selfSigned = status
}

// Your API Key
func (clt *Client) SetKey(value string) {
	clt.AddHeader("X-Appwrite-Key", value)
}

// AddHeader add a new custom header that the Client should send on each request
func (clt *Client) AddHeader(key string, value string) {
	clt.headers[key] = value
}
{% for header in spec.global.headers %}

{% if header.description %}
// {{header.description}}
{% endif %}
func (clt *Client) Set{{header.key | caseUcfirst}}(value string) {
	clt.headers["{{header.name}}"] = value
}
{% endfor %}

// Call an API using Client
func (clt *Client) Call(method string, path string, headers map[string]interface{}, params map[string]interface{}) (map[string]interface{}, error) {
	if clt.client == nil {
		// Create HTTP client
		httpClient, err := getDefaultClient(clt.timeout)
		if err != nil { panic(err) }
		clt.client = httpClient
	}

	if clt.selfSigned {
		http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	}

	urlPath := clt.endpoint + path
	isGet := strings.ToUpper(method) == "GET"
	isJsonRequest := headers["content-type"] == "application/json"
	var reqBody *strings.Reader
	if !isGet {
		if !isJsonRequest {
			frm := url.Values{}
			for key, val := range params {
				frm.Add(key, ToString(val))
			}
			reqBody = strings.NewReader(frm.Encode())
		} else {
			json, err := json.Marshal(params)
			if err != nil {
				return nil, err
			}
			reqBody = strings.NewReader(string(json))
		}
	} else {
		frm := url.Values{}
		for key, val := range params {
			frm.Add(key, ToString(val))
		}
	}

	// Create and modify HTTP request before sending
	req, err := http.NewRequest(method, urlPath, reqBody)
	if err != nil {
		return nil, err
	}

	// Set Client headers
	for key, val := range clt.headers {
		req.Header.Set(key, ToString(val))
	}

	//Set default headers
{% for key,header in spec.global.defaultHeaders %}
	req.Header.Set("{{key}}", "{{header}}")
{% endfor %}

	// Set Custom headers
	for key, val := range headers {
		req.Header.Set(key, ToString(val))
	}

	if isGet {
		q := req.URL.Query()
		for key, val := range params {
			q.Add(key, ToString(val))
		}
		req.URL.RawQuery = q.Encode()
	}

	// Make request
	response, err := clt.client.Do(req)
	if err != nil {
		return nil, err
	}

	// Handle response
	defer response.Body.Close()
 
	responseData, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	var jsonResponse map[string]interface{}
	json.Unmarshal(responseData, &jsonResponse)
	return jsonResponse, nil
}
