import { File } from "node-fetch-native-with-agent";

// Conditionally import fs modules to support edge runtimes
let basename: ((path: string) => string) | undefined;
let realpathSync: ((path: string) => string) | undefined;
let fs: {
  stat: (path: string) => Promise<{ size: number }>;
  open: (path: string, flags: string) => Promise<{
    read: (buffer: Buffer, offset: number, length: number, position: number) => Promise<{ bytesRead: number }>;
    close: () => Promise<void>;
  }>;
  readFile: (path: string) => Promise<Buffer>;
} | undefined;

// Detect if we're in an edge runtime
const isEdgeRuntime = typeof globalThis !== 'undefined' && typeof (globalThis as any).EdgeRuntime !== 'undefined';

// Only import fs modules if not in edge runtime
// Using dynamic import() for ES modules with Promise.all for efficiency
const fsModulesPromise = !isEdgeRuntime
  ? Promise.all([
      import("path"),
      import("fs")
    ]).then(([pathModule, fsModule]) => {
      basename = pathModule.basename;
      realpathSync = fsModule.realpathSync;
      fs = fsModule.promises;
    }).catch(() => {
      // If imports fail, fs will remain undefined
    })
  : Promise.resolve();
type BlobLike = {
  size: number;
  slice: (start: number, end: number) => BlobLike;
  arrayBuffer: () => Promise<ArrayBuffer>;
};

type InputFileSource =
  | { type: 'path'; path: string }
  | { type: 'buffer'; data: Buffer }
  | { type: 'blob'; data: BlobLike };

export class InputFile {
  private source: InputFileSource;
  filename: string;

  private constructor(source: InputFileSource, filename: string) {
    this.source = source;
    this.filename = filename;
  }

  static fromBuffer(parts: BlobLike | Buffer | Uint8Array | ArrayBuffer | string, name: string): InputFile {
    if (parts && typeof (parts as BlobLike).arrayBuffer === 'function') {
      return new InputFile({ type: 'blob', data: parts as BlobLike }, name);
    }

    if (Buffer.isBuffer(parts)) {
      return new InputFile({ type: 'buffer', data: parts }, name);
    }

    if (typeof parts === 'string') {
      return new InputFile({ type: 'buffer', data: Buffer.from(parts) }, name);
    }

    if (parts instanceof ArrayBuffer) {
      return new InputFile({ type: 'buffer', data: Buffer.from(parts) }, name);
    }

    if (ArrayBuffer.isView(parts)) {
      return new InputFile({
        type: 'buffer',
        data: Buffer.from(parts.buffer, parts.byteOffset, parts.byteLength),
      }, name);
    }

    throw new Error('Unsupported input type for InputFile.fromBuffer');
  }

  static fromPath(path: string, name?: string): InputFile {
    if (!realpathSync || !basename) {
      throw new Error('InputFile.fromPath is not supported in edge runtimes. Please use InputFile.fromBuffer instead.');
    }
    const realPath = realpathSync(path);
    return new InputFile({ type: 'path', path: realPath }, name ?? basename(realPath));
  }

  static fromPlainText(content: string, name: string): InputFile {
    return new InputFile({ type: 'buffer', data: Buffer.from(content) }, name);
  }

  async size(): Promise<number> {
    switch (this.source.type) {
      case 'path':
        if (!fs) {
          throw new Error('File system operations are not supported in edge runtimes.');
        }
        return (await fs.stat(this.source.path)).size;
      case 'buffer':
        return this.source.data.length;
      case 'blob':
        return this.source.data.size;
    }
  }

  async slice(start: number, end: number): Promise<Buffer> {
    const length = end - start;

    switch (this.source.type) {
      case 'path': {
        if (!fs) {
          throw new Error('File system operations are not supported in edge runtimes.');
        }
        const handle = await fs.open(this.source.path, 'r');
        try {
          const buffer = Buffer.alloc(length);
          const result = await handle.read(buffer, 0, length, start);
          return result.bytesRead === buffer.length ? buffer : buffer.subarray(0, result.bytesRead);
        } finally {
          await handle.close();
        }
      }
      case 'buffer':
        return this.source.data.subarray(start, end);
      case 'blob': {
        const arrayBuffer = await this.source.data.slice(start, end).arrayBuffer();
        return Buffer.from(arrayBuffer);
      }
    }
  }

  async toFile(): Promise<File> {
    const buffer = await this.toBuffer();
    return new File([buffer], this.filename);
  }

  private async toBuffer(): Promise<Buffer> {
    switch (this.source.type) {
      case 'path':
        if (!fs) {
          throw new Error('File system operations are not supported in edge runtimes.');
        }
        return await fs.readFile(this.source.path);
      case 'buffer':
        return this.source.data;
      case 'blob':
        return Buffer.from(await this.source.data.arrayBuffer());
    }
  }
}
