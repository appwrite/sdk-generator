import Foundation
import AsyncHTTPClient
import NIO
import NIOHTTP1

open class Realtime : Service {

    private let TYPE_ERROR = "error"
    private let TYPE_EVENT = "event"
    private let TYPE_PONG = "pong"
    private let DEBOUNCE_NANOS = 1_000_000
    private let HEARTBEAT_INTERVAL: UInt64 = 20_000_000_000 // 20 seconds in nanoseconds

    private var socketClient: WebSocketClient? = nil
    // Slot-centric state: Map<slot, { channels: Set<String>, queries: [String], callback: Function }>
    private var activeSubscriptions = [Int: RealtimeCallback]()
    private var activeSubscriptionQueries = [Int: [String]]() // Map slot -> queries array
    // Map slot index -> subscriptionId (from backend)
    private var slotToSubscriptionId = [Int: String]()
    // Inverse map: subscriptionId -> slot index (for O(1) lookup)
    private var subscriptionIdToSlot = [String: Int]()
    private var heartbeatTask: Task<Void, Swift.Error>? = nil

    let connectSync = DispatchQueue(label: "ConnectSync")

    private var subCallDepth = 0
    private var reconnectAttempts = 0
    private var subscriptionsCounter = 0
    private var reconnect = true
    
    private var onErrorCallbacks: [((Swift.Error?, HTTPResponseStatus?) -> Void)] = []
    private var onCloseCallbacks: [(() -> Void)] = []
    private var onOpenCallbacks: [(() -> Void)] = []

    public func onError(_ callback: @escaping (Swift.Error?, HTTPResponseStatus?) -> Void) {
        self.onErrorCallbacks.append(callback)
    }
    
    public func onClose(_ callback: @escaping () -> Void) {
        self.onCloseCallbacks.append(callback)
    }
    
    public func onOpen(_ callback: @escaping () -> Void) {
        self.onOpenCallbacks.append(callback)
    }

    private func startHeartbeat() {
        stopHeartbeat()
        heartbeatTask = Task {
            do {
                while !Task.isCancelled {
                    if let client = socketClient, client.isConnected {
                        client.send(text: #"{"type": "ping"}"#)
                    }
                    try await Task.sleep(nanoseconds: HEARTBEAT_INTERVAL)
                }
            } catch {
                if !Task.isCancelled {
                    print("Heartbeat task failed: \(error.localizedDescription)")
                }
            }
        }
    }

    private func stopHeartbeat() {
        heartbeatTask?.cancel()
        heartbeatTask = nil
    }

    private func createSocket() async throws {
        // Rebuild activeChannels from all slots
        var allChannels = Set<String>()
        for subscription in activeSubscriptions.values {
            allChannels.formUnion(subscription.channels)
        }

        guard allChannels.count > 0 else {
            reconnect = false
            try await closeSocket()
            return
        }

        var queryParams = "project=\(client.config["project"]!)"

        for channel in allChannels {
            let encodedChannel = channel.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? channel
            queryParams += "&channels[]=\(encodedChannel)"
        }

        // Build query string from slots → channels → queries
        // Format: channel[slot][]=query (each query sent as separate parameter)
        // For each slot, repeat its queries under each channel it subscribes to
        // Example: slot 1 → channels [tests, prod], queries [q1, q2]
        //   Produces: tests[1][]=q1&tests[1][]=q2&prod[1][]=q1&prod[1][]=q2
        let selectAllQuery = Query.select(["*"])
        for (slot, subscription) in activeSubscriptions {
            // Get queries array - each query is a separate string
            let queries = activeSubscriptionQueries[slot] ?? []
            let queryArray = queries.isEmpty ? [selectAllQuery] : queries
            
            // Repeat this slot's queries under each channel it subscribes to
            // Each query is sent as a separate parameter: channel[slot][]=q1&channel[slot][]=q2
            for channel in subscription.channels {
                let encodedChannel = channel.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? channel
                for query in queryArray {
                    let encodedQuery = query.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? query
                    queryParams += "&\(encodedChannel)[\(slot)][]=\(encodedQuery)"
                }
            }
        }

        let url = "\(client.endPointRealtime!)/realtime?\(queryParams)"

        if (socketClient != nil) {
            reconnect = false
            try await closeSocket()
        }

        socketClient = WebSocketClient(
            url,
            tlsEnabled: !client.selfSigned,
            delegate: self
        )

        try await socketClient?.connect()
    }

    private func closeSocket() async throws {
        stopHeartbeat()
        
        guard let client = socketClient,
              let group = client.threadGroup else {
            return
        }

        if (client.isConnected) {
            let promise = group.any().makePromise(of: Void.self)
            client.close(promise: promise)
            try await promise.futureResult.get()
        }

        try await group.shutdownGracefully()
    }

    private func getTimeout() -> Int {
        switch reconnectAttempts {
        case 0..<5: return 1000
        case 5..<15: return 5000
        case 15..<100: return 10000
        default: return 60000
        }
    }

    /**
     * Convert channel value to string
     * All Channel instances and String conform to ChannelValue
     */
    private func channelToString(_ channel: ChannelValue) -> String {
        return channel.toString()
    }

    public func subscribe(
        channel: ChannelValue,
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set([channelToString(channel)]),
            payloadType: String.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe(
        channels: [ChannelValue],
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set(channels.map { channelToString($0) }),
            payloadType: String.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe<T : Codable>(
        channel: ChannelValue,
        payloadType: T.Type,
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set([channelToString(channel)]),
            payloadType: T.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe<T : Codable>(
        channels: [ChannelValue],
        payloadType: T.Type,
        callback: @escaping (RealtimeResponseEvent) -> Void,
        queries: [String] = []
    ) async throws -> RealtimeSubscription {
        return try await subscribe(
            channels: Set(channels.map { channelToString($0) }),
            payloadType: T.self,
            queries: queries,
            callback: callback
        )
    }

    public func subscribe<T : Codable>(
        channels: Set<String>,
        payloadType: T.Type,
        queries: [String] = [],
        callback: @escaping (RealtimeResponseEvent) -> Void
    ) async throws -> RealtimeSubscription {
        // Allocate a new slot index
        subscriptionsCounter += 1
        let slot = subscriptionsCounter

        // Convert queries to array of strings
        // queries is already [String], store as-is
        let queryStrings = queries

        // Store slot-centric data: channels, queries, and callback belong to the slot
        // queries is stored as [String] (array of query strings)
        // No channel mutation occurs here - channels are derived from slots in createSocket()
        activeSubscriptions[slot] = RealtimeCallback(
            for: channels,
            with: callback
        )
        activeSubscriptionQueries[slot] = queryStrings

        connectSync.sync {
            subCallDepth += 1
        }

        try await Task.sleep(nanoseconds: UInt64(DEBOUNCE_NANOS))

        if self.subCallDepth == 1 {
            try await self.createSocket()
        }

        connectSync.sync {
            self.subCallDepth -= 1
        }

        return RealtimeSubscription {
            let subscriptionId = self.slotToSubscriptionId[slot]
            self.activeSubscriptions[slot] = nil
            self.activeSubscriptionQueries[slot] = nil
            self.slotToSubscriptionId[slot] = nil
            if let sid = subscriptionId {
                self.subscriptionIdToSlot[sid] = nil
            }
            try await self.createSocket()
        }
    }

    // cleanUp is no longer needed - slots are removed directly in subscribe().close()
    // Channels are automatically rebuilt from remaining slots in createSocket()
}

extension Realtime: WebSocketClientDelegate {

    public func onOpen(channel: NIO.Channel) {
        self.reconnectAttempts = 0
        onOpenCallbacks.forEach { $0() }
        startHeartbeat()
    }
    
    private func handleResponseConnected(from json: [String: Any]) {
        guard let data = json["data"] as? [String: Any],
              let subscriptions = data["subscriptions"] as? [String: String] else {
            return
        }
        
        // Store subscription ID mappings from backend
        // Format: { "0": "sub_a1f9", "1": "sub_b83c", ... }
        slotToSubscriptionId.removeAll()
        subscriptionIdToSlot.removeAll()
        for (slotStr, subscriptionId) in subscriptions {
            if let slot = Int(slotStr) {
                slotToSubscriptionId[slot] = subscriptionId
                subscriptionIdToSlot[subscriptionId] = slot
            }
        }
    }

    public func onMessage(text: String) {
        let data = Data(text.utf8)
        guard let json = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
              let type = json["type"] as? String else {
            return
        }
        
        switch type {
        case TYPE_ERROR:
            do {
                try handleResponseError(from: json)
            } catch {
                onErrorCallbacks.forEach { $0(error, nil) }
            }
        case "connected":
            handleResponseConnected(from: json)
        case TYPE_EVENT:
            handleResponseEvent(from: json)
        case TYPE_PONG:
            break  // Handle pong response if needed
        default:
            break
        }
    }

    public func onClose(channel: NIO.Channel, data: Data) async throws {
        stopHeartbeat()

        onCloseCallbacks.forEach { $0() }
        
        if (!reconnect) {
            reconnect = true
            return
        }

        let timeout = getTimeout()

        print("Realtime disconnected. Re-connecting in \(timeout / 1000) seconds.")

        try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000))

        self.reconnectAttempts += 1

        try await self.createSocket()
    }

    public func onError(error: Swift.Error?, status: HTTPResponseStatus?) {
        stopHeartbeat()
        print(error?.localizedDescription ?? "Unknown error")

        onErrorCallbacks.forEach { $0(error, status) }
    }

    func handleResponseError(from json: [String: Any]) throws {
        throw {{ spec.title | caseUcfirst }}Error(message: json["message"] as? String ?? "Unknown error")
    }

    func handleResponseEvent(from json: [String: Any]) {
        guard let data = json["data"] as? [String: Any],
              let channels = data["channels"] as? [String],
              let events = data["events"] as? [String],
              let payload = data["payload"] as? [String: Any],
              let subscriptions = data["subscriptions"] as? [String] else {
            return
        }

        guard subscriptions.count > 0 else {
            return
        }

        // Iterate over all matching subscriptionIds and call callback for each
        for subscriptionId in subscriptions {
            // O(1) lookup using subscriptionId
            if let slot = subscriptionIdToSlot[subscriptionId] {
                if let subscription = activeSubscriptions[slot] {
                    let response = RealtimeResponseEvent(
                        events: events,
                        channels: channels,
                        timestamp: data["timestamp"] as! String,
                        payload: payload
                    )
                    subscription.callback(response)
                }
            }
        }
    }
}
